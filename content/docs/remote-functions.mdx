---
title: "Remote Functions"
---

Remote Functions are the building blocks of iii applications - arbitrary functions that can be executed from anywhere in the system.

## What are Remote Functions?

A **Remote Function** is a function registered with the iii Engine that can be invoked:

- By triggers (API requests, events, cron schedules)
- By other functions
- Directly via the SDK

```mermaid
graph TD
    API[API Trigger] -->|Invokes| Func[Remote Function]
    Event[Event Trigger] -->|Invokes| Func
    Cron[Cron Trigger] -->|Invokes| Func
    Other[Another Function] -->|Invokes| Func
    Direct[Direct SDK Call] -->|Invokes| Func

    Func -->|Calls| DB[(Database)]
    Func -->|Calls| External[External API]
    Func -->|Emits| Events[Events]
```

## Function Registration

Functions are registered by workers during initialization:

```typescript
bridge.registerFunction({
  functionPath: 'service.action',
  handler: async (data, context) => {
    // Function logic here
    return result;
  },
  description: 'Optional description',
  metadata: { version: '1.0' }  // Optional metadata
});
```

### Function Path

The `functionPath` is a unique identifier using dot notation:

**Pattern**: `service.action`

**Examples**:
- `users.create`
- `users.update`
- `auth.login`
- `payments.process`
- `api.echo`

**Best Practices**:
- Use lowercase
- Use dots to separate service and action
- Be descriptive but concise
- Version if needed: `users.create.v2`

## Function Handler

The handler is an async function that receives input data and context:

```typescript
async function handler(data: any, context?: Context) {
  // Access input data
  const { name, email } = data;

  // Perform business logic
  const result = await processData(name, email);

  // Return result
  return result;
}
```

### Input Data

The structure of `data` depends on the trigger type:

| Trigger Type | Data Structure |
|--------------|----------------|
| **api** | `ApiRequest` with path_params, query_params, body, headers |
| **event** | Event payload (any JSON) |
| **cron** | Cron execution context |
| **log** | Log entry object |
| **direct** | Whatever was passed to `invokeFunction` |

### Return Value

Functions should return:

- **API triggers**: `ApiResponse` with status, body, headers
- **Event triggers**: Any JSON value (or void)
- **Cron triggers**: Any JSON value (or void)
- **Direct calls**: Any JSON value

## Function Invocation

### Via Triggers

Most common pattern - triggers automatically invoke functions:

```typescript
// 1. Register function
bridge.registerFunction({
  functionPath: 'users.create',
  handler: async (req) => {
    const user = await db.createUser(req.body);
    return { status: 201, body: user };
  }
});

// 2. Register trigger
bridge.registerTrigger({
  triggerType: 'api',
  functionPath: 'users.create',
  config: { api_path: '/users', http_method: 'POST' }
});

// 3. Function is invoked when HTTP POST /users is received
```

### Direct Invocation

Call functions directly from other functions:

```typescript
bridge.registerFunction({
  functionPath: 'users.sendWelcome',
  handler: async (user) => {
    await sendEmail(user.email, 'Welcome!');
  }
});

bridge.registerFunction({
  functionPath: 'users.create',
  handler: async (data) => {
    const user = await db.createUser(data);

    // Invoke another function
    await bridge.invokeFunction({
      functionPath: 'users.sendWelcome',
      data: user
    });

    return user;
  }
});
```

### Cross-Worker Invocation

Functions can invoke functions in other workers:

```mermaid
sequenceDiagram
    participant W1 as Worker1
    participant E as Engine
    participant W2 as Worker2

    W1->>E: invokeFunction('worker2.process')
    E->>W2: Invoke worker2.process
    W2->>W2: Execute function
    W2-->>E: Return result
    E-->>W1: Return result
```

```typescript
// Worker 1 - API handler
bridge.registerFunction({
  functionPath: 'api.processOrder',
  handler: async (req) => {
    // Call function in Worker 2
    const result = await bridge.invokeFunction({
      functionPath: 'payments.charge',  // In Worker 2
      data: { amount: req.body.amount }
    });

    return { status: 200, body: result };
  }
});

// Worker 2 - Payment processor
bridge.registerFunction({
  functionPath: 'payments.charge',
  handler: async ({ amount }) => {
    const charge = await stripe.charge(amount);
    return { chargeId: charge.id };
  }
});
```

## Function Schemas

Define input/output schemas for documentation and validation:

```typescript
bridge.registerFunction({
  functionPath: 'users.create',
  handler: async (data) => { /* ... */ },
  description: 'Create a new user account',
  request_format: {
    type: 'object',
    properties: {
      name: { type: 'string' },
      email: { type: 'string', format: 'email' },
      age: { type: 'number', minimum: 18 }
    },
    required: ['name', 'email']
  },
  response_format: {
    type: 'object',
    properties: {
      id: { type: 'string' },
      name: { type: 'string' },
      email: { type: 'string' }
    }
  }
});
```

## Function Context

Functions receive an optional context object with runtime information:

```typescript
bridge.registerFunction({
  functionPath: 'example.handler',
  handler: async (data, context) => {
    // Access context
    console.log('Trace ID:', context.trace_id);
    console.log('Invocation ID:', context.invocation_id);
    console.log('Trigger:', context.trigger);

    return result;
  }
});
```

**Context Fields**:
- `trace_id`: Distributed tracing identifier
- `invocation_id`: Unique ID for this invocation
- `trigger`: Information about what triggered the function

## Error Handling

Functions should handle errors gracefully:

```typescript
bridge.registerFunction({
  functionPath: 'users.create',
  handler: async (req) => {
    try {
      // Validate input
      if (!req.body.email) {
        return {
          status: 400,
          body: { error: 'Email is required' }
        };
      }

      // Perform operation
      const user = await db.createUser(req.body);

      return {
        status: 201,
        body: user
      };
    } catch (error) {
      // Log error
      console.error('Failed to create user:', error);

      // Return error response
      return {
        status: 500,
        body: {
          error: 'Internal server error',
          message: error.message
        }
      };
    }
  }
});
```

## Common Patterns

### CRUD Operations

```typescript
// Create
bridge.registerFunction({
  functionPath: 'users.create',
  handler: async (req) => {
    const user = await db.insert(req.body);
    return { status: 201, body: user };
  }
});

// Read
bridge.registerFunction({
  functionPath: 'users.get',
  handler: async (req) => {
    const user = await db.findById(req.path_params.id);
    if (!user) return { status: 404, body: { error: 'Not found' } };
    return { status: 200, body: user };
  }
});

// Update
bridge.registerFunction({
  functionPath: 'users.update',
  handler: async (req) => {
    const user = await db.update(req.path_params.id, req.body);
    return { status: 200, body: user };
  }
});

// Delete
bridge.registerFunction({
  functionPath: 'users.delete',
  handler: async (req) => {
    await db.delete(req.path_params.id);
    return { status: 204, body: null };
  }
});
```

### Event Emission

```typescript
bridge.registerFunction({
  functionPath: 'orders.create',
  handler: async (req) => {
    // Create order
    const order = await db.createOrder(req.body);

    // Emit event
    await bridge.invokeFunction({
      functionPath: 'event.emit',
      data: {
        topic: 'order.created',
        data: order
      }
    });

    return { status: 201, body: order };
  }
});
```

### Function Composition

```typescript
// Utility function
bridge.registerFunction({
  functionPath: 'utils.validateEmail',
  handler: async ({ email }) => {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }
});

// Main function using utility
bridge.registerFunction({
  functionPath: 'users.create',
  handler: async (req) => {
    // Call utility function
    const isValid = await bridge.invokeFunction({
      functionPath: 'utils.validateEmail',
      data: { email: req.body.email }
    });

    if (!isValid) {
      return { status: 400, body: { error: 'Invalid email' } };
    }

    // Continue with creation
    const user = await db.createUser(req.body);
    return { status: 201, body: user };
  }
});
```

### Background Jobs

```typescript
bridge.registerFunction({
  functionPath: 'api.processLarge',
  handler: async (req) => {
    // Queue background job (fire and forget)
    bridge.invokeFunction({
      functionPath: 'jobs.processData',
      data: req.body
    }).catch(err => console.error('Job failed:', err));

    // Return immediately
    return {
      status: 202,
      body: { message: 'Processing started' }
    };
  }
});

bridge.registerFunction({
  functionPath: 'jobs.processData',
  handler: async (data) => {
    // Long-running process
    await processLargeDataset(data);

    // Emit completion event
    await bridge.invokeFunction({
      functionPath: 'event.emit',
      data: {
        topic: 'processing.completed',
        data: { jobId: data.id }
      }
    });
  }
});
```

## Best Practices

<AccordionGroup>
  <Accordion title="Keep Functions Focused">
    Each function should have a single responsibility:

    ```typescript
    // Good: Focused functions
    bridge.registerFunction({ functionPath: 'users.create', ... });
    bridge.registerFunction({ functionPath: 'users.sendWelcome', ... });

    // Avoid: Doing too much in one function
    bridge.registerFunction({
      functionPath: 'users.createAndEmailAndLog',
      handler: async (data) => {
        const user = await createUser(data);
        await sendEmail(user);
        await logActivity(user);
        await updateMetrics(user);
        // Too many responsibilities
      }
    });
    ```
  </Accordion>

  <Accordion title="Use Consistent Naming">
    Follow a naming convention across your application:

    ```typescript
    // Resource.action pattern
    'users.create'
    'users.update'
    'orders.process'
    'payments.charge'

    // Or service.resource.action for larger apps
    'api.users.create'
    'api.orders.list'
    'jobs.cleanup.old'
    ```
  </Accordion>

  <Accordion title="Return Structured Errors">
    Always return consistent error formats:

    ```typescript
    // Good
    return {
      status: 400,
      body: {
        error: 'VALIDATION_ERROR',
        message: 'Email is required',
        field: 'email'
      }
    };

    // Avoid: Inconsistent error responses
    return { status: 400, body: 'bad request' };
    ```
  </Accordion>

  <Accordion title="Log Important Events">
    Use logging for debugging and monitoring:

    ```typescript
    bridge.registerFunction({
      functionPath: 'payments.charge',
      handler: async (data, context) => {
        console.log(`[${context.trace_id}] Processing payment`, data);

        try {
          const result = await processPayment(data);
          console.log(`[${context.trace_id}] Payment successful`, result);
          return result;
        } catch (error) {
          console.error(`[${context.trace_id}] Payment failed`, error);
          throw error;
        }
      }
    });
    ```
  </Accordion>
</AccordionGroup>

## Next Steps

<Columns cols={2}>
  <Card icon="Recycle" title="Triggers" href="/docs/triggers">
    Learn how to connect functions to triggers
  </Card>
  <Card icon="Code" title="Quick Start" href="/docs/quickstart">
    Build your first iii application
  </Card>
</Columns>
