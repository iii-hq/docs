---
title: "KV Server Module"
---

Key-Value storage server for persistent data storage with support for in-memory and file-based backends.

```
modules::kv_server::KvServer
```

## Sample Configuration

```yaml
  - class: modules::kv_server::KvServer
    config:
      store_method: file_based
      file_path: ./data/kv_store
      save_interval_ms: 5000
```

## Configuration

<ResponseField name="store_method" type="string">
  The storage method to use. Options are:
  - `in_memory` - Data is stored only in memory (lost on restart)
  - `file_based` - Data is persisted to disk
</ResponseField>

<ResponseField name="file_path" type="string">
  The file path where data will be stored when using `file_based` storage method.
</ResponseField>

<ResponseField name="save_interval_ms" type="number">
  The interval in milliseconds between automatic saves when using `file_based` storage. Defaults to `5000`.
</ResponseField>

## Functions

<ResponseField name="kv_server.get" type="function">
  Get a value by key from the KV store.

  <AccordionGroup>
    <Accordion iconName="settings" title="Parameters">
      <ResponseField name="key" type="string" required>
        The key to retrieve the value for.
      </ResponseField>
    </Accordion>
    <Accordion title="Returns">
      <ResponseField name="value" type="any">
        The value stored at the key, or `null` if the key does not exist.
      </ResponseField>
    </Accordion>
  </AccordionGroup>
</ResponseField>

<ResponseField name="kv_server.set" type="function">
  Set a value by key in the KV store.

  <AccordionGroup>
    <Accordion iconName="settings" title="Parameters">
      <ResponseField name="key" type="string" required>
        The key to store the value under.
      </ResponseField>
      <ResponseField name="value" type="any" required>
        The value to store. Can be any JSON-serializable value.
      </ResponseField>
    </Accordion>
    <Accordion title="Returns">
      <ResponseField name="result" type="object">
        The result of the set operation containing information about the stored value.
      </ResponseField>
    </Accordion>
  </AccordionGroup>
</ResponseField>

<ResponseField name="kv_server.delete" type="function">
  Delete a value by key from the KV store.

  <AccordionGroup>
    <Accordion iconName="settings" title="Parameters">
      <ResponseField name="key" type="string" required>
        The key to delete.
      </ResponseField>
    </Accordion>
    <Accordion title="Returns">
      <ResponseField name="value" type="any">
        The deleted value, or `null` if the key did not exist.
      </ResponseField>
    </Accordion>
  </AccordionGroup>
</ResponseField>

<ResponseField name="kv_server.list_keys_with_prefix" type="function">
  List all keys that match a given prefix.

  <AccordionGroup>
    <Accordion iconName="settings" title="Parameters">
      <ResponseField name="prefix" type="string" required>
        The prefix to match keys against.
      </ResponseField>
    </Accordion>
    <Accordion title="Returns">
      <ResponseField name="keys" type="string[]">
        An array of keys that match the given prefix.
      </ResponseField>
    </Accordion>
  </AccordionGroup>
</ResponseField>

<ResponseField name="kv_server.list" type="function">
  List all values that match a given key pattern.

  <AccordionGroup>
    <Accordion iconName="settings" title="Parameters">
      <ResponseField name="key" type="string" required>
        The key pattern to match.
      </ResponseField>
    </Accordion>
    <Accordion title="Returns">
      <ResponseField name="values" type="any[]">
        An array of values matching the key pattern.
      </ResponseField>
    </Accordion>
  </AccordionGroup>
</ResponseField>

## Usage Examples

### Basic Key-Value Operations

```typescript
import { bridge } from 'iii';

// Set a value
await bridge.invoke('kv_server.set', { 
  key: 'user:123', 
  value: { name: 'John', email: 'john@example.com' } 
});

// Get a value
const user = await bridge.invoke('kv_server.get', { key: 'user:123' });
console.log(user); // { name: 'John', email: 'john@example.com' }

// Delete a value
await bridge.invoke('kv_server.delete', { key: 'user:123' });
```

### Listing Keys with Prefix

```typescript
// Store some users
await bridge.invoke('kv_server.set', { key: 'user:1', value: { name: 'Alice' } });
await bridge.invoke('kv_server.set', { key: 'user:2', value: { name: 'Bob' } });
await bridge.invoke('kv_server.set', { key: 'product:1', value: { name: 'Widget' } });

// List all user keys
const userKeys = await bridge.invoke('kv_server.list_keys_with_prefix', { 
  prefix: 'user:' 
});
console.log(userKeys); // ['user:1', 'user:2']
```

## Update Operations

The KV Server supports atomic update operations for modifying values in place.

<Tip>
Update operations are available through the `KVStoreAdapter` interface and are used internally by other modules (e.g., streams). These operations are not currently exposed as a public `kv_server.update` function but can be accessed through the adapter when building custom modules or extensions.
</Tip>

<Expandable title="UpdateOp Types">
  <ResponseField name="Set" type="object">
    Set a value at a specific path (overwrite).
    ```json
    { "Set": { "path": "field.nested", "value": "new value" } }
    ```
  </ResponseField>
  
  <ResponseField name="Merge" type="object">
    Merge an object into existing value (object-only).
    ```json
    { "Merge": { "path": null, "value": { "newField": "value" } } }
    ```
  </ResponseField>
  
  <ResponseField name="Increment" type="object">
    Increment a numeric value.
    ```json
    { "Increment": { "path": "counter", "by": 1 } }
    ```
  </ResponseField>
  
  <ResponseField name="Decrement" type="object">
    Decrement a numeric value.
    ```json
    { "Decrement": { "path": "counter", "by": 1 } }
    ```
  </ResponseField>
  
  <ResponseField name="Remove" type="object">
    Remove a field from the value.
    ```json
    { "Remove": { "path": "fieldToRemove" } }
    ```
  </ResponseField>
</Expandable>

### Update Operations Examples

Below are practical examples showing how update operations work. These operations are atomic, meaning multiple updates can be applied together without race conditions.

#### Set Operation

Update a specific nested field:

```typescript
// Update user's last login timestamp
await adapter.update('user:123', [
  { Set: { path: 'profile.lastLogin', value: new Date().toISOString() } }
]);

// Before: { name: 'John', profile: { email: 'john@example.com' } }
// After:  { name: 'John', profile: { email: 'john@example.com', lastLogin: '2026-01-23T10:30:00Z' } }
```

#### Merge Operation

Add fields without overwriting existing ones:

```typescript
// Add premium status to user
await adapter.update('user:123', [
  { Merge: { path: null, value: { isPremium: true, premiumSince: '2026-01-23' } } }
]);

// Before: { name: 'John', email: 'john@example.com' }
// After:  { name: 'John', email: 'john@example.com', isPremium: true, premiumSince: '2026-01-23' }
```

#### Increment Operation

Increment counters:

```typescript
// Increment post view count
await adapter.update('post:456', [
  { Increment: { path: 'views', by: 1 } }
]);

// Increment login count
await adapter.update('user:123', [
  { Increment: { path: 'stats.loginCount', by: 1 } }
]);

// Before: { stats: { loginCount: 5 } }
// After:  { stats: { loginCount: 6 } }
```

#### Decrement Operation

Decrement values (e.g., inventory management):

```typescript
// Reduce product stock
await adapter.update('product:789', [
  { Decrement: { path: 'inventory.stock', by: 1 } }
]);

// Before: { inventory: { stock: 10 } }
// After:  { inventory: { stock: 9 } }
```

#### Remove Operation

Delete a field from the value:

```typescript
// Remove temporary access token
await adapter.update('user:123', [
  { Remove: { path: 'tempToken' } }
]);

// Before: { name: 'John', tempToken: 'abc123' }
// After:  { name: 'John' }
```

#### Composite Operations

Multiple atomic operations in a single update:

```typescript
// Update multiple fields atomically
await adapter.update('user:123', [
  { Increment: { path: 'loginCount', by: 1 } },
  { Set: { path: 'lastLogin', value: new Date().toISOString() } },
  { Set: { path: 'lastIp', value: '192.168.1.1' } }
]);

// All operations succeed or fail together (atomic)
// Before: { name: 'John', loginCount: 10, lastLogin: '2026-01-20T08:00:00Z' }
// After:  { name: 'John', loginCount: 11, lastLogin: '2026-01-23T10:30:00Z', lastIp: '192.168.1.1' }
```

#### Real-World Use Case: Stream Module

The stream module uses update operations internally for managing stream state:

```typescript
// When a new message is added to a stream
await adapter.update(`stream:${streamId}`, [
  { Increment: { path: 'messageCount', by: 1 } },
  { Set: { path: 'lastMessageAt', value: new Date().toISOString() } },
  { Set: { path: 'lastMessageId', value: messageId } }
]);
```
