---
title: 'Function & Trigger'
description: 'Register Functions with the engine and trigger them from anywhere — any language, any worker.'
---

A **Function** is anything that can be called to do work it receives input, and optionally returns output.
It can exist anywhere be it locally, on cloud, on serverless, or even as a 3rd party HTTP endpoint.
All functionality deconstructs into the same function. It can mutate state, invoke other functions,
modify databases, and do anything that a typical function can do. 

A **Trigger** is what causes a Function to run — either explicitly from code, or automatically from an event source
like an HTTP request or cron job.

```mermaid
graph LR
    subgraph W1[Worker A]
        direction TB
        F1([Function A])
        F2([Function B])
    end

    W1 -- "trigger(id, data)" --> E[Engine]

    subgraph W2[Worker B]
        direction TB
        F3([Function C])
    end

    W2 -- registerFunction --> E

    F1 -- registerFunction --> E -- trigger --> W2
```

## Registering a Function and Trigger it

Function registration is just passing a function, and an `id` for the function to a register function call.
Cal

<Tabs items={["TypeScript", "Python", "Rust"]}>
<Tab value="TypeScript">
```typescript
import { init } from 'iii-sdk';

const iii = init('ws://localhost:49134');

iii.registerFunction(
  { id: 'math::add', description: 'Add two numbers' },
  async (input) => {
    return { result: input.a + input.b };
  },
);

const result = await iii.trigger('math::add', { a: 2, b: 3 });
console.log(result);
await iii.shutdown();
```
</Tab>
<Tab value="Python">
```python
from iii import III
import asyncio

iii = III('ws://localhost:49134')

async def add(data):
    return {'result': data['a'] + data['b']}

async def register():
    iii.register_function('math::add', add)
    await iii.connect()
    result = await iii.trigger('math::add', {'a': 2, 'b': 3})
    print(result)

asyncio.run(register())
```
</Tab>
<Tab value="Rust">
```rust
use iii_sdk::III;
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let iii = III::new("ws://127.0.0.1:49134");
    iii.connect().await?;

    iii.register_function("math::add", |input| async move {
        let a = input["a"].as_i64().unwrap_or(0);
        let b = input["b"].as_i64().unwrap_or(0);
        Ok(json!({ "result": a + b }))
    });

    let result = iii.trigger("math::add", json!({ "a": 2, "b": 3 })).await?;
    println!("{:?}", result);
    Ok(())
}
```
</Tab>
</Tabs>

Once registered, `math::add` is triggerable from anywhere in the system.

## Ways to Trigger Functions

As shown above functions can be triggered with `trigger(id, data)` but there are actually
two ways to trigger them and a way to register additional Triggers that fire Functions
according to internal and external events.

| Method | Returns | Use when |
|--------|---------|----------|
| `trigger(id, data)` | The function's result | You need the result |
| `triggerVoid(id, data)` | Nothing | Fire-and-forget, don't block |
| `registerTrigger(config)` | n/a | Event-based: HTTP, cron, queue, state changes, etc. |

### `trigger()` — Await the result

<Tabs items={["TypeScript", "Python", "Rust"]}>
<Tab value="TypeScript">
```typescript
const result = await iii.trigger('math::add', { a: 2, b: 3 })
console.log(result) // { result: 5 }
```
</Tab>
<Tab value="Python">
```python
result = await iii.trigger('math::add', {'a': 2, 'b': 3})
print(result)  # {'result': 5}
```
</Tab>
<Tab value="Rust">
```rust
let result = iii.trigger("math::add", json!({"a": 2, "b": 3})).await?;
println!("{:?}", result); // {"result": 5}
```
</Tab>
</Tabs>

### `triggerVoid()` — Fire and forget

<Tabs items={["TypeScript", "Python", "Rust"]}>
<Tab value="TypeScript">
```typescript
iii.triggerVoid('math::add', { a: 2, b: 3 })
// returns immediately
```
</Tab>
<Tab value="Python">
```python
iii.trigger_void('math::add', {'a': 2, 'b': 3})
# returns immediately
```
</Tab>
<Tab value="Rust">
```rust
iii.trigger_void("math::add", json!({"a": 2, "b": 3}));
// returns immediately
```
</Tab>
</Tabs>

### `registerTrigger()` — Run on an event

Bind a Function to an event source. The engine triggers it automatically when the event fires:

<Tabs items={["HTTP", "Cron", "State"]}>
<Tab value="HTTP">
```typescript
iii.registerTrigger({
  type: 'http',
  function_id: 'math::add',
  config: { api_path: '/math/add', http_method: 'POST' },
})
```
</Tab>
<Tab value="Cron">
```typescript
iii.registerTrigger({
  type: 'cron',
  function_id: 'math::add',
  config: { expression: '0 * * * *' },
})
// triggers reports::generate every hour
```
</Tab>
<Tab value="State">
```typescript
iii.registerTrigger({
  type: 'state',
  function_id: 'audit::log',
  config: { scope: 'orders', key: 'status' },
})
// triggers audit::log when orders::status changes
```
</Tab>
</Tabs>

<Callout type="info" title="Queue uses enqueue">
  Queue messaging uses `enqueue` — a built-in function, no trigger registration needed: `iii.trigger('enqueue', { topic: 'user.created', data: {...} })`. See the [Queue module](/docs/modules/module-queue) for details.
</Callout>

`registerTrigger()` returns a handle so you can remove the trigger later:

```typescript
const t = iii.registerTrigger({ type: 'http', function_id: 'fn::id', config: { api_path: '/ping', http_method: 'GET' } })
t.unregister()
```

## Trigger Types

| Type | Fires when | Config fields | Module |
|------|-----------|---------------|--------|
| `http` | HTTP request received | `api_path`, `http_method` | HTTP |
| `cron` | Schedule fires | `expression` | Cron |
| `queue` | Message published to a topic | `topic` | Queue |
| `subscribe` | PubSub message on a topic | `topic` | PubSub |
| `state` | State value changes | `scope`, `key` | State |
| `stream` | Stream value changes | `stream_name`, `group_id`, `item_id` | Stream |
| `stream:join` | Client connects to stream | — | Stream |
| `stream:leave` | Client disconnects from stream | — | Stream |
| `log` | Log entry emitted | `level` | Observability |

## Cross-language triggering

Any worker can trigger any Function regardless of language. The engine handles serialization and routing:

<Tabs items={["TypeScript", "Python", "Rust"]}>
<Tab value="TypeScript">
```typescript
const result = await iii.trigger('math::add', { a: 2, b: 3 })
console.log(result) // { result: 5 }
```
</Tab>
<Tab value="Python">
```python
result = await iii.trigger('math::add', {'a': 2, 'b': 3})
print(result)  # {'result': 5}
```
</Tab>
<Tab value="Rust">
```rust
let result = iii.trigger("math::add", json!({"a": 2, "b": 3})).await?;
println!("{:?}", result); // {"result": 5}
```
</Tab>
</Tabs>

The triggering worker doesn't know or care what language the target is written in.

Once a Function is registered, every other worker in the system can discover and trigger it. See [Discovery](/docs/concepts/discovery) for how this works, including built-in functions the engine provides.

## Function IDs

Function IDs use a `namespace::name` convention:

```
math::add
orders::process
notifications::send
```

The `engine::` prefix is reserved for internal engine functions.

<Cards>
  <Card icon={<Search />} title="Discovery" href="/docs/concepts/discovery">
    How workers discover functions and built-in capabilities at runtime.
  </Card>
  <Card icon={<Code />} title="SDK Reference" href="/docs/api-reference/iii-sdk">
    Full API reference for registerFunction, trigger, triggerVoid, and more.
  </Card>
  <Card icon={<Terminal />} title="Quickstart" href="/docs/tutorials/quickstart">
    Start building with Functions and Triggers.
  </Card>
</Cards>
