---
title: 'Function & Trigger'
description: 'Register Functions with the engine and trigger them from anywhere — any language, any service.'
---

A **Function** is anything that can be called to do work; it receives input, and optionally returns output.
It can exist anywhere be it locally, on cloud, on serverless, or even as a 3rd party HTTP endpoint.
All functionality deconstructs into the same function. It can mutate state, invoke other functions,
modify databases, and do anything that a typical function can do. 

A **Trigger** is what causes a Function to run — either explicitly from code, or automatically from an event source
like an HTTP request or cron job.

```mermaid
graph LR
    subgraph W1[Worker A]
        direction TB
        F1([Function A])
        F2([Function B])
    end

    W1 -- "trigger(id, data)" --> E[Engine]

    subgraph W2[Worker B]
        direction TB
        F3([Function C])
    end

    W2 -- registerFunction --> E

    F1 -- registerFunction --> E -- trigger --> W2
```

## Registering a Function and Triggering it

Function registration is just passing a function, and an `id` for the function to `registerFunction(id, func)`
(or the equivalent in other languages). These functions can then be Triggered from anywhere else in the
application, and across language and service boundaries. Read more on that in the [Cross-language Triggering](#cross-language-triggering) section below.

Once registered, `math::add` is triggerable from anywhere in the system. This example also stores
each result in state so it can be aggregated later by a cron job.

<Tabs items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
import { init } from 'iii-sdk';

const iii = init(process.env.III_BRIDGE_URL ?? 'ws://localhost:49134');

iii.registerFunction(
    { id: 'math::add', description: 'Add two numbers and store result' },
    async (input) => {
        const result = input.a + input.b;
        const id = crypto.randomUUID();
        await iii.trigger('state::set', { scope: 'math', key: id, value: result });
        return { id, result };
    },
);

const result = await iii.trigger('math::add', { a: 2, b: 3 });
console.log(result); // { id: '...', result: 5 }
await iii.shutdown();
```
</Tab>
<Tab value="Python">
```python
from iii import III
import asyncio
import os
import uuid

iii = III(os.environ.get('III_BRIDGE_URL', 'ws://localhost:49134'))

async def add(data):
    result = data['a'] + data['b']
    id = str(uuid.uuid4())
    await iii.trigger('state::set', {'scope': 'math', 'key': id, 'value': result})
    return {'id': id, 'result': result}

async def main():
    iii.register_function('math::add', add)
    await iii.connect()
    result = await iii.trigger('math::add', {'a': 2, 'b': 3})
    print(result)  # {'id': '...', 'result': 5}

asyncio.run(main())
```
</Tab>
<Tab value="Rust">
```rust
use iii_sdk::III;
use serde_json::json;
use uuid::Uuid;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let url = std::env::var("III_BRIDGE_URL").unwrap_or_else(|_| "ws://127.0.0.1:49134".to_string());
    let iii = III::new(&url);
    iii.connect().await?;

    let iii_clone = iii.clone();
    iii.register_function("math::add", move |input| {
        let iii = iii_clone.clone();
        async move {
            let a = input["a"].as_i64().unwrap_or(0);
            let b = input["b"].as_i64().unwrap_or(0);
            let result = a + b;
            let id = Uuid::new_v4().to_string();
            iii.trigger("state::set", json!({ "scope": "math", "key": id, "value": result })).await?;
            Ok(json!({ "id": id, "result": result }))
        }
    });

    let result = iii.trigger("math::add", json!({ "a": 2, "b": 3 })).await?;
    println!("{:?}", result); // {"id": "...", "result": 5}
    Ok(())
}
```
</Tab>
</Tabs>

## Ways to Trigger Functions

As shown above functions can be triggered with `trigger(id, data)` but there are actually
two ways to trigger them and a way to register additional Triggers that fire Functions
according to internal and external events.

| Method | Returns | Use when |
|--------|---------|----------|
| `trigger(id, data)` | The function's result | You **need** the result |
| `triggerVoid(id, data)` | Nothing | You **don't need** the result |
| `registerTrigger(config)` | n/a | You need a function triggered as the result of another event such as: HTTP requests, Cron jobs, Queues, and State changes. |

### `trigger()` — Await the result

<Tabs items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
const result = await iii.trigger('math::add', { a: 2, b: 3 })
console.log(result) // { result: 5 }
```
</Tab>
<Tab value="Python">
```python
result = await iii.trigger('math::add', {'a': 2, 'b': 3})
print(result)  # {'result': 5}
```
</Tab>
<Tab value="Rust">
```rust
let result = iii.trigger("math::add", json!({"a": 2, "b": 3})).await?;
println!("{:?}", result); // {"result": 5}
```
</Tab>
</Tabs>

### `triggerVoid()` — Fire and forget

<Tabs items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
iii.triggerVoid('math::add', { a: 2, b: 3 })
// returns immediately
```
</Tab>
<Tab value="Python">
```python
iii.trigger_void('math::add', {'a': 2, 'b': 3})
# returns immediately
```
</Tab>
<Tab value="Rust">
```rust
iii.trigger_void("math::add", json!({"a": 2, "b": 3}))?;
// returns immediately
```
</Tab>
</Tabs>

### `registerTrigger()` — Run on an event

Bind a Function to an event source. The engine triggers it automatically when the event fires. Below are
examples for common Trigger types: HTTP, Cron, and State.

#### HTTP

HTTP triggers receive an `ApiRequest` object with `body`, `query_params`, `path_params`, `headers`, and `method`.
The handler returns an `ApiResponse` with `status_code`, `body`, and optional `headers`.

{/* TODO: Replace the wrapper functions below with the new native way to register http endpoints as triggerable
functions once that functionality is available. */}

<Tabs items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
iii.registerFunction({ id: 'math::multiply' }, async (req) => {
    const { a, b } = req.body;
    return {
        status_code: 200,
        body: { result: a * b },
        headers: { 'Content-Type': 'application/json' },
    };
});

iii.registerTrigger({
    type: 'http',
    function_id: 'math::multiply',
    config: { api_path: '/math/multiply', http_method: 'POST' },
});
```
</Tab>
<Tab value="Python">
```python
async def multiply(req):
    a, b = req['body']['a'], req['body']['b']
    return {
        'status_code': 200,
        'body': {'result': a * b},
        'headers': {'Content-Type': 'application/json'},
    }

iii.register_function('math::multiply', multiply)

iii.register_trigger(
    type="http",
    function_id="math::multiply",
    config={"api_path": "/math/multiply", "http_method": "POST"},
)
```
</Tab>
<Tab value="Rust">
```rust
iii.register_function("math::multiply", |req| async move {
    let a = req["body"]["a"].as_i64().unwrap_or(0);
    let b = req["body"]["b"].as_i64().unwrap_or(0);
    Ok(json!({
        "status_code": 200,
        "body": { "result": a * b },
        "headers": { "Content-Type": "application/json" }
    }))
});

iii.register_trigger(
    "http",
    "math::multiply",
    json!({ "api_path": "/math/multiply", "http_method": "POST" }),
)?;
```
</Tab>
</Tabs>

#### Cron

This example aggregates all stored math results (from `math::add` above) every 30 minutes.

<Tabs items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
iii.registerFunction({ id: 'math::aggregation' }, async () => {
    const results = await iii.trigger('state::list', { scope: 'math' });
    const values = results.map((r: { value: number }) => r.value);
    const sum = values.reduce((a: number, b: number) => a + b, 0);
    return { count: values.length, sum, average: sum / values.length };
});

iii.registerTrigger({
    type: 'cron',
    function_id: 'math::aggregation',
    config: { expression: '0 */30 * * * *' }, // every 30 minutes
});
```
</Tab>
<Tab value="Python">
```python
async def aggregation(_):
    results = await iii.trigger('state::list', {'scope': 'math'})
    values = [r['value'] for r in results]
    total = sum(values)
    return {'count': len(values), 'sum': total, 'average': total / len(values) if values else 0}

iii.register_function('math::aggregation', aggregation)

iii.register_trigger(
    type="cron",
    function_id="math::aggregation",
    config={"expression": "0 */30 * * * *"},  # every 30 minutes
)
```
</Tab>
<Tab value="Rust">
```rust
let iii_clone = iii.clone();
iii.register_function("math::aggregation", move |_| {
    let iii = iii_clone.clone();
    async move {
        let results = iii.trigger("state::list", json!({ "scope": "math" })).await?;
        let values: Vec<i64> = results.as_array()
            .map(|arr| arr.iter().filter_map(|r| r["value"].as_i64()).collect())
            .unwrap_or_default();
        let sum: i64 = values.iter().sum();
        let count = values.len();
        Ok(json!({ "count": count, "sum": sum, "average": sum as f64 / count as f64 }))
    }
});

iii.register_trigger(
    "cron",
    "math::aggregation",
    json!({ "expression": "0 */30 * * * *" }), // every 30 minutes
)?;
```
</Tab>
</Tabs>

#### State

State triggers fire when a value in state changes. This example posts to an external webhook
whenever an order's status is updated.

<Tabs items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
iii.registerFunction({ id: 'orders::webhook' }, async (event) => {
    await fetch(process.env.WEBHOOK_URL!, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ order_id: event.key, status: event.value }),
    });
});

iii.registerTrigger({
    type: 'state',
    function_id: 'orders::webhook',
    config: { scope: 'orders', key: 'status' },
});
```
</Tab>
<Tab value="Python">
```python
import httpx

async def webhook(event):
    async with httpx.AsyncClient() as client:
        await client.post(
            os.environ['WEBHOOK_URL'],
            json={'order_id': event['key'], 'status': event['value']},
        )

iii.register_function('orders::webhook', webhook)

iii.register_trigger(
    type="state",
    function_id="orders::webhook",
    config={"scope": "orders", "key": "status"},
)
```
</Tab>
<Tab value="Rust">
```rust
use iii_sdk::III;
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let url = std::env::var("III_BRIDGE_URL").unwrap_or_else(|_| "ws://127.0.0.1:49134".to_string());
    let iii = III::new(&url);
    iii.connect().await?;

    iii.register_function("orders::webhook", |event| async move {
        let client = reqwest::Client::new();
        let url = std::env::var("WEBHOOK_URL").expect("WEBHOOK_URL required");
        if let Err(e) = client.post(&url)
            .json(&json!({ "order_id": event["key"], "status": event["value"] }))
            .send()
            .await
        {
            return Ok(json!({ "error": e.to_string() }));
        }
        Ok(json!({}))
    });

    iii.register_trigger(
        "state",
        "orders::webhook",
        json!({ "scope": "orders", "key": "status" }),
    )?;

    Ok(())
}
```
</Tab>
</Tabs>

{/* TODO: Update this, enqueue is its entirely own thing */}

{/* <Callout type="info" title="Queue uses enqueue">
  Queue messaging uses `enqueue` — a built-in function, no trigger registration needed: `iii.trigger('enqueue', { topic: 'user.created', data: {...} })`. See the [Queue module](/docs/modules/module-queue) for details.
</Callout> */}

#### Removing Triggers

`registerTrigger()` returns a handle so you can remove the trigger later:

<Tabs items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
const t = iii.registerTrigger({
    type: 'http',
    function_id: 'fn::id',
    config: { api_path: '/ping', http_method: 'GET' }
})
t.unregister()
```
</Tab>
<Tab value="Python">
```python
t = iii.register_trigger(
    type='http',
    function_id='fn::id',
    config={'api_path': '/ping', 'http_method': 'GET'}
)
t.unregister()
```
</Tab>
<Tab value="Rust">
```rust
let t = iii.register_trigger(
    "http",
    "fn::id",
    json!({"api_path": "/ping", "http_method": "GET"}),
)?;
t.unregister();
```
</Tab>
</Tabs>

## Trigger Types

| Type | Fires when | Config fields | Module |
|------|-----------|---------------|--------|
| `http` | HTTP request received | `api_path`, `http_method` | HTTP |
| `cron` | Schedule fires | `expression` | Cron |
| `queue` | Message published to a topic | `topic` | Queue |
| `subscribe` | PubSub message on a topic | `topic` | PubSub |
| `state` | State value changes | `scope`, `key` | State |
| `stream` | Stream value changes | `stream_name`, `group_id`, `item_id` | Stream |
| `stream:join` | Client connects to stream | — | Stream |
| `stream:leave` | Client disconnects from stream | — | Stream |
| `log` | Log entry emitted | `level` | Observability |

## Cross-language triggering

Any Function can be Triggered anywhere regardless of language. The engine handles serialization and routing:

<Tabs items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
const result = await iii.trigger('math::add', { a: 2, b: 3 })
console.log(result) // { result: 5 }
```
</Tab>
<Tab value="Python">
```python
result = await iii.trigger('math::add', {'a': 2, 'b': 3})
print(result)  # {'result': 5}
```
</Tab>
<Tab value="Rust">
```rust
let result = iii.trigger("math::add", json!({"a": 2, "b": 3})).await?;
println!("{:?}", result); // {"result": 5}
```
</Tab>
</Tabs>

The triggering Function doesn't know what language the target is written in or where it's running.

Once a Function is registered, every other part of the system can discover and trigger it. See [Discovery](/docs/concepts/discovery) for how this works, including built-in functions the engine provides.

## Function IDs

Function IDs use a `namespace::name` convention:

```
math::add
orders::process
notifications::send
```

The `engine::` prefix is reserved for internal engine functions.

<Cards>
  <Card icon={<Search />} title="Discovery" href="/docs/concepts/discovery">
    Learn how functions are discovered by the iii engine.
  </Card>
  <Card icon={<Code />} title="SDK Reference" href="/docs/api-reference/iii-sdk">
    Full API reference for registerFunction, trigger, triggerVoid, and more.
  </Card>
  <Card icon={<Terminal />} title="Quickstart" href="/docs/tutorials/quickstart">
    Start building with Functions and Triggers.
  </Card>
</Cards>
