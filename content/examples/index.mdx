---
title: 'Examples'
description: 'Real-world code examples for every trigger type and pattern — shown in TypeScript, Python, and Rust.'
---

Each example uses the **iii SDK** directly. Every page shows the same pattern in three languages so you can pick whichever fits your stack.

<Cards>
  <Card title="Hello World" href="/docs/examples/hello-world">
    An HTTP endpoint that publishes an event and a background handler that processes it. The simplest end-to-end flow.
  </Card>
  <Card title="Todo App" href="/docs/examples/todo-app">
    Full CRUD (create, update, delete) backed by a custom stream implementation, showing `iii.createStream`.
  </Card>
  <Card title="Multi-Trigger" href="/docs/examples/multi-trigger">
    One function registered with multiple triggers — HTTP, queue, and cron — with per-trigger dispatch logic.
  </Card>
  <Card title="Conditions" href="/docs/examples/conditions">
    Pre-handler functions the engine evaluates before a trigger fires — if the condition returns false, the handler is not called.
  </Card>
  <Card title="State Management" href="/docs/examples/state-management">
    Read and write distributed key-value state via `state::get` / `state::set` and react to changes.
  </Card>
  <Card title="Cron Jobs" href="/docs/examples/cron">
    Schedule recurring tasks with cron expressions and fan out work through the queue.
  </Card>
  <Card title="Observability" href="/docs/examples/observability">
    Structured logging, trace ID propagation, and OpenTelemetry across a multi-step workflow.
  </Card>
</Cards>

## SDK model

All three SDKs share the same concepts with language-idiomatic initialization:

- **TypeScript**: `init(url)` — named function, connection is automatic
- **Python**: `III(address=url)` — class constructor (`__init__` convention), then call `await iii.connect()`
- **Rust**: `III::new(url)` — `new` is the Rust convention for constructors, then call `iii.connect().await?`

| Concept | TypeScript | Python | Rust |
|---|---|---|---|
| Init | `init(url)` | `III(address=url)` | `III::new(url)` |
| Connect | Auto on `init()` | `await iii.connect()` | `iii.connect().await?` |
| Register function | `iii.registerFunction({ id }, handler)` | `iii.register_function(function_id, handler)` | `iii.register_function(id, \|input\| ...)` |
| Register trigger | `iii.registerTrigger({ type, function_id, config })` | `iii.register_trigger(type, function_id, config)` | `iii.register_trigger(type, function_id, config)?` |
| Context | `getContext()` | `get_context()` | `iii_sdk::get_context()` |
| Trigger (sync) | `await iii.trigger(id, data)` | `await iii.trigger(function_id, data)` | `iii.trigger(id, data).await?` |
| Trigger (fire-and-forget) | `iii.triggerVoid(id, data)` | `iii.trigger_void(function_id, data)` | `iii.trigger_void(id, data)?` |
| Publish event | `await iii.trigger('enqueue', { topic, data })` | `await iii.trigger("enqueue", {...})` | `iii.trigger_void("enqueue", json!({...}))?` |
| State write | `await iii.trigger('state::set', { scope, key, data })` | `await iii.trigger("state::set", {...})` | `iii.trigger_void("state::set", json!({...}))?` |
| Stream write | `iii.trigger('stream::set', { stream_name, group_id, item_id, data })` | `await iii.trigger("stream::set", {...})` | `streams.update(key, ops).await?` |

<Callout title="No framework required" type="info">
  These examples use the iii SDK directly, with no Motia framework layer. There are no auto-discovered step files. Each worker is a plain application that connects, registers its functions and triggers, then enters an event loop.
</Callout>
