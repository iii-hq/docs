---
title: 'Expose an HTTP Endpoint'
description: 'How to register a function and expose it as a REST API endpoint.'
---

## Goal

Expose a Function as an HTTP endpoint so external clients can call it via REST.

## Steps

### 1. Register the Function

<Tabs items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
import { init } from 'iii-sdk'

const iii = init('ws://localhost:49134')

iii.registerFunction(
  { id: 'users::create' },
  async (req) => {
    const { name, email } = req.body
    const user = { id: crypto.randomUUID(), name, email }
    return { status_code: 201, body: user }
  }
)

// ...place registerTrigger here...
```
</Tab>
<Tab value="Python">
```python
import asyncio
import signal
import uuid
import os
from iii import III

iii = III(os.environ.get('III_BRIDGE_URL', 'ws://localhost:49134'))

async def create_user(req):
    name = req['body']['name']
    email = req['body']['email']
    user = {'id': str(uuid.uuid4()), 'name': name, 'email': email}
    return {'status_code': 201, 'body': user}

iii.register_function('users::create', create_user)

# ...place register_trigger here...

async def main():
    await iii.connect()
    print("HTTP endpoint ready on POST /users")
    stop = asyncio.Event()
    loop = asyncio.get_running_loop()
    for sig in (signal.SIGINT, signal.SIGTERM):
        loop.add_signal_handler(sig, stop.set)
    await stop.wait()

asyncio.run(main())
```
</Tab>
<Tab value="Rust">
```rust
use iii_sdk::III;
use serde_json::json;
use tokio::signal;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let url = std::env::var("III_BRIDGE_URL").unwrap_or_else(|_| "ws://127.0.0.1:49134".to_string());
    let iii = III::new(&url);
    iii.connect().await?;

    iii.register_function("users::create", |req| async move {
        let name = req["body"]["name"].as_str().unwrap_or("");
        let email = req["body"]["email"].as_str().unwrap_or("");
        Ok(json!({
            "status_code": 201,
            "body": { "id": uuid::Uuid::new_v4().to_string(), "name": name, "email": email }
        }))
    });

    // ...place register_trigger here...

    println!("HTTP endpoint ready on POST /users");
    signal::ctrl_c().await?;

    Ok(())
}
```
</Tab>
</Tabs>

### 2. Register the HTTP Trigger

<Tabs items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
iii.registerTrigger({
  type: 'http',
  function_id: 'users::create',
  config: { api_path: '/users', http_method: 'POST' },
})
```
</Tab>
<Tab value="Python">
```python
iii.register_trigger(
    type="http",
    function_id="users::create",
    config={"api_path": "/users", "http_method": "POST"},
)
```
</Tab>
<Tab value="Rust">
```rust
iii.register_trigger(
    "http",
    "users::create",
    json!({ "api_path": "/users", "http_method": "POST" }),
)?;
```
</Tab>
</Tabs>

### 3. Enable the REST API module

Make sure `iii-config.yaml` has the REST API module enabled:

```yaml
  - class: modules::api::RestApiModule
    config:
      port: 3111
      host: localhost
      default_timeout: 30000
      concurrency_request_limit: 1024
      cors:
        allowed_origins:
          # To allow all origins, use '*':
          # - '*'
          - localhost
        allowed_methods:
          - GET
          - POST
          - PUT
          - DELETE
          - OPTIONS
```

### 4. Test it

```bash
curl -X POST http://localhost:3111/users \
  -H "Content-Type: application/json" \
  -d '{"name": "Alice", "email": "alice@example.com"}'
```

## Result

Your Function is now accessible as `POST /users` on port 3111. The `http` trigger handles request parsing and response serialization automatically.

<Callout title="Request and Response types" type="info">
  HTTP-triggered Functions receive an `ApiRequest` and should return an `ApiResponse`. See the [SDK Reference](/docs/api-reference/iii-sdk) for type details.
</Callout>
