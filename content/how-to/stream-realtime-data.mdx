---
title: 'Stream Real-Time Data'
description: 'How to push live updates to connected clients using the Stream module.'
---

## Goal

Push real-time updates (chat messages, notifications, live dashboards) to connected clients over WebSocket.

## Steps

### 1. Enable the Stream module

```yaml
modules:
  - class: modules::stream::StreamModule
    config:
      port: ${STREAM_PORT:3112}
      host: 127.0.0.1
      adapter:
        class: modules::stream::adapters::KvStore
        config:
          store_method: in_memory  # Options: in_memory, file_based
          # file_path: ./data/stream_store  # required for file_based
        # class: modules::stream::adapters::RedisAdapter
        # config:
        #   redis_url: redis://localhost:6379
```

### 2. Write to a stream from a Function

<Tabs groupId="language" persist items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
import { init } from 'iii-sdk'

const iii = init('ws://localhost:49134')

iii.registerFunction(
  { id: 'chat::send-message' },
  async (data) => {
    const message = {
      id: crypto.randomUUID(),
      text: data.text,
      author: data.author,
      timestamp: Date.now(),
    }

    await iii.trigger('stream::set', {
      stream_name: 'chat',
      group_id: data.roomId,
      item_id: message.id,
      data: message,
    })

    return message
  }
)
```
</Tab>
<Tab value="Python">
```python
import asyncio
import os
import signal
import time
import uuid
from iii import III

iii = III(os.environ.get('III_BRIDGE_URL', 'ws://localhost:49134'))

async def send_message(data):
    message = {
        'id': str(uuid.uuid4()),
        'text': data['text'],
        'author': data['author'],
        'timestamp': int(time.time() * 1000),
    }
    await iii.trigger('stream::set', {
        'stream_name': 'chat',
        'group_id': data['roomId'],
        'item_id': message['id'],
        'data': message,
    })
    return message

iii.register_function('chat::send-message', send_message)

async def main():
    await iii.connect()
    stop = asyncio.Event()
    loop = asyncio.get_running_loop()
    for sig in (signal.SIGINT, signal.SIGTERM):
        loop.add_signal_handler(sig, stop.set)
    await stop.wait()

asyncio.run(main())
```
</Tab>
<Tab value="Rust">
```rust
use iii_sdk::III;
use serde_json::json;
use tokio::signal;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let url = std::env::var("III_BRIDGE_URL").unwrap_or_else(|_| "ws://127.0.0.1:49134".to_string());
    let iii = III::new(&url);
    iii.connect().await?;

    iii.register_function("chat::send-message", |data| async move {
        let id = uuid::Uuid::new_v4().to_string();
        let message = json!({
            "id": id,
            "text": data["text"],
            "author": data["author"],
            "timestamp": chrono::Utc::now().timestamp_millis(),
        });

        iii.trigger("stream::set", json!({
            "stream_name": "chat",
            "group_id": data["roomId"],
            "item_id": message["id"],
            "data": message,
        })).await?;

        Ok(message)
    });

    signal::ctrl_c().await?;
    Ok(())
}
```
</Tab>
</Tabs>

### 3. Read from a stream

<Tabs groupId="language" persist items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
const messages = await iii.trigger('stream::list', {
  stream_name: 'chat',
  group_id: 'room-123',
})
```
</Tab>
<Tab value="Python">
```python
messages = await iii.trigger('stream::list', {
    'stream_name': 'chat',
    'group_id': 'room-123',
})
```
</Tab>
<Tab value="Rust">
```rust
let messages = iii.trigger("stream::list", json!({
    "stream_name": "chat",
    "group_id": "room-123",
})).await?;
```
</Tab>
</Tabs>

### 4. Connect a client

Clients connect to the stream WebSocket endpoint to receive live updates:

```javascript
const ws = new WebSocket('ws://localhost:3112/stream/chat/room-123')

ws.onmessage = (event) => {
  const update = JSON.parse(event.data)
  console.log('New message:', update)
}
```

## Result

Any data written to the stream via `stream::set` is immediately pushed to all connected WebSocket clients subscribed to that stream and group. No polling needed.

<Callout title="See also" type="info">
  For stream operations like `update`, `delete`, `listGroups`, and authentication, see the [Stream module reference](/docs/modules/module-stream).
</Callout>
