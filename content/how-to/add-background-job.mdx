---
title: 'Add a Background Job'
description: 'How to process work asynchronously using the Queue module.'
---

## Goal

Offload slow or unreliable work (sending emails, processing images, calling external APIs) to a background queue so your HTTP endpoint responds immediately.

## Steps

### 1. Enable the Queue module

```yaml
modules:
  - class: modules::queue::QueueModule
    config:
      adapter:
        class: modules::queue::BuiltinQueueAdapter
        config:
          store_method: in_memory  # Options: in_memory, file_based
          # file_path: ./data/queue_store  # required for file_based
        # class: modules::queue::RedisAdapter
        # config:
        #   redis_url: redis://localhost:6379
```

### 2. Register the background Function

<Tabs groupId="language" persist items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
import { init } from 'iii-sdk'

const iii = init('ws://localhost:49134')

iii.registerFunction(
  { id: 'emails::send-welcome' },
  async (data) => {
    return { sent: true, to: data.to }
  }
)
```
</Tab>
<Tab value="Python">
```python
import asyncio
import os
import signal
from iii import III

iii = III(os.environ.get('III_BRIDGE_URL', 'ws://localhost:49134'))

async def send_welcome(data):
    return {'sent': True, 'to': data['to']}

iii.register_function('emails::send-welcome', send_welcome)

async def main():
    await iii.connect()
    stop = asyncio.Event()
    loop = asyncio.get_running_loop()
    for sig in (signal.SIGINT, signal.SIGTERM):
        loop.add_signal_handler(sig, stop.set)
    await stop.wait()

asyncio.run(main())
```
</Tab>
<Tab value="Rust">
```rust
use iii_sdk::III;
use serde_json::json;
use tokio::signal;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let url = std::env::var("III_BRIDGE_URL").unwrap_or_else(|_| "ws://127.0.0.1:49134".to_string());
    let iii = III::new(&url);
    iii.connect().await?;

    iii.register_function("emails::send-welcome", |data| async move {
        let to = data["to"].as_str().unwrap_or("");
        Ok(json!({ "sent": true, "to": to }))
    });

    signal::ctrl_c().await?;
    Ok(())
}
```
</Tab>
</Tabs>

### 3. Trigger it asynchronously from another Function

Use `triggerVoid()` (fire-and-forget) so the calling Function doesn't wait:

<Tabs groupId="language" persist items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
iii.registerFunction(
  { id: 'users::create' },
  async (req) => {
    const user = { id: crypto.randomUUID(), ...req.body }

    iii.triggerVoid('emails::send-welcome', {
      to: user.email,
      body: `Hi ${user.name}, welcome!`,
    })

    return { status_code: 201, body: user }
  }
)
```
</Tab>
<Tab value="Python">
```python
async def create_user(req):
    import uuid
    user = {'id': str(uuid.uuid4()), **req['body']}

    iii.trigger_void('emails::send-welcome', {
        'to': user['email'],
        'body': f"Hi {user['name']}, welcome!",
    })

    return {'status_code': 201, 'body': user}

iii.register_function('users::create', create_user)
```
</Tab>
<Tab value="Rust">
```rust
iii.register_function("users::create", |req| async move {
    let user_id = uuid::Uuid::new_v4().to_string();
    let email = req["body"]["email"].as_str().unwrap_or("");
    let name = req["body"]["name"].as_str().unwrap_or("");

    iii.trigger_void("emails::send-welcome", json!({
        "to": email,
        "body": format!("Hi {}, welcome!", name),
    })).await?;

    Ok(json!({ "status_code": 201, "body": { "id": user_id, "name": name, "email": email } }))
});
```
</Tab>
</Tabs>

## Result

The HTTP endpoint returns `201` immediately while the email is sent in the background. If the email Function fails, it does not affect the user creation response.

<Callout title="Queue triggers" type="info">
  For more advanced patterns like retry policies, dead-letter queues, and batching, see the [Queue module reference](/docs/modules/module-queue).
</Callout>
