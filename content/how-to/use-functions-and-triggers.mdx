---
title: 'Using Functions & Triggers'
description: 'Learn how to register Functions and Trigger them from anywhere within your backend across languages and from any service.'
---

## Registering a Function and Triggering it

Function registration is just passing a function, an `id` for the function to `registerFunction({id}, func)`
(or the equivalent in other languages). These functions can then be Triggered from anywhere else in the
application, and across language and service boundaries. Read more on that in the [Cross-language Triggering](#cross-language-triggering) section below.

Once registered, `math::add` is triggerable from anywhere in the system. This example also stores
each result in state so it can be aggregated later by a cron job.

<Tabs groupId="language" persist items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
import { init } from 'iii-sdk';

const iii = init(process.env.III_BRIDGE_URL ?? 'ws://localhost:49134');

iii.registerFunction(
    { id: 'math::add', description: 'Add two numbers and store result' },
    async (input) => {
        const result = input.a + input.b;
        const id = crypto.randomUUID();
        await iii.trigger('state::set', { scope: 'math', key: id, value: result });
        return { id, result };
    },
);

const result = await iii.trigger('math::add', { a: 2, b: 3 });
console.log(result); // { id: '...', result: 5 }
```
</Tab>
<Tab value="Python">
```python
from iii import III
import asyncio
import os
import uuid

iii = III(os.environ.get('III_BRIDGE_URL', 'ws://localhost:49134'))

async def add(data):
    result = data['a'] + data['b']
    id = str(uuid.uuid4())
    await iii.trigger('state::set', {'scope': 'math', 'key': id, 'value': result})
    return {'id': id, 'result': result}

async def main():
    iii.register_function('math::add', add)
    await iii.connect()
    result = await iii.trigger('math::add', {'a': 2, 'b': 3})
    print(result)  # {'id': '...', 'result': 5}

asyncio.run(main())
```
</Tab>
<Tab value="Rust">
```rust
use iii_sdk::III;
use serde_json::json;
use uuid::Uuid;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let url = std::env::var("III_BRIDGE_URL").unwrap_or_else(|_| "ws://127.0.0.1:49134".to_string());
    let iii = III::new(&url);
    iii.connect().await?;

    let iii_clone = iii.clone();
    iii.register_function("math::add", move |input| {
        let iii = iii_clone.clone();
        async move {
            let a = input["a"].as_i64().unwrap_or(0);
            let b = input["b"].as_i64().unwrap_or(0);
            let result = a + b;
            let id = Uuid::new_v4().to_string();
            iii.trigger("state::set", json!({ "scope": "math", "key": id, "value": result })).await?;
            Ok(json!({ "id": id, "result": result }))
        }
    });

    let result = iii.trigger("math::add", json!({ "a": 2, "b": 3 })).await?;
    println!("{:?}", result); // {"id": "...", "result": 5}
    Ok(())
}
```
</Tab>
</Tabs>

## Ways to Trigger Functions

As shown above functions can be triggered with `trigger(id, data)` but there are actually
two ways to trigger them and a way to register additional Triggers that fire Functions
according to internal and external events.

| Method | Returns | Use when |
|--------|---------|----------|
| `trigger(id, data)` | The function's result | You **need** the result |
| `triggerVoid(id, data)` | Nothing | You **don't need** the result |
| `registerTrigger(config)` | n/a | You need a function triggered as the result of another event such as: HTTP requests, Cron jobs, Queues, and State changes. |

### `trigger()` — Await the result

<Tabs groupId="language" persist items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
const result = await iii.trigger('math::add', { a: 2, b: 3 })
console.log(result) // { result: 5 }
```
</Tab>
<Tab value="Python">
```python
result = await iii.trigger('math::add', {'a': 2, 'b': 3})
print(result)  # {'result': 5}
```
</Tab>
<Tab value="Rust">
```rust
let result = iii.trigger("math::add", json!({"a": 2, "b": 3})).await?;
println!("{:?}", result); // {"result": 5}
```
</Tab>
</Tabs>

### `triggerVoid()` — Fire and forget

<Tabs groupId="language" persist items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
iii.triggerVoid('math::add', { a: 2, b: 3 })
// returns immediately
```
</Tab>
<Tab value="Python">
```python
iii.trigger_void('math::add', {'a': 2, 'b': 3})
# returns immediately
```
</Tab>
<Tab value="Rust">
```rust
iii.trigger_void("math::add", json!({"a": 2, "b": 3}))?;
// returns immediately
```
</Tab>
</Tabs>

### `registerTrigger()` — Run on an event

Bind a Function to an event source. The engine triggers it automatically when the event fires. Below are
examples for common Trigger types: HTTP, Cron, and State.

#### HTTP

HTTP triggers receive an `ApiRequest` object with `body`, `query_params`, `path_params`, `headers`, and `method`.
The handler returns an `ApiResponse` with `status_code`, `body`, and optional `headers`.

{/* TODO: Replace the wrapper functions below with the new native way to register http endpoints as triggerable
functions once that functionality is available. */}

<Tabs groupId="language" persist items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
iii.registerFunction({ id: 'math::multiply' }, async (req) => {
    const { a, b } = req.body;
    return {
        status_code: 200,
        body: { result: a * b },
        headers: { 'Content-Type': 'application/json' },
    };
});

iii.registerTrigger({
    type: 'http',
    function_id: 'math::multiply',
    config: { api_path: '/math/multiply', http_method: 'POST' },
});
```
</Tab>
<Tab value="Python">
```python
async def multiply(req):
    a, b = req['body']['a'], req['body']['b']
    return {
        'status_code': 200,
        'body': {'result': a * b},
        'headers': {'Content-Type': 'application/json'},
    }

iii.register_function('math::multiply', multiply)

iii.register_trigger(
    type="http",
    function_id="math::multiply",
    config={"api_path": "/math/multiply", "http_method": "POST"},
)
```
</Tab>
<Tab value="Rust">
```rust
iii.register_function("math::multiply", |req| async move {
    let a = req["body"]["a"].as_i64().unwrap_or(0);
    let b = req["body"]["b"].as_i64().unwrap_or(0);
    Ok(json!({
        "status_code": 200,
        "body": { "result": a * b },
        "headers": { "Content-Type": "application/json" }
    }))
});

iii.register_trigger(
    "http",
    "math::multiply",
    json!({ "api_path": "/math/multiply", "http_method": "POST" }),
)?;
```
</Tab>
</Tabs>

#### Cron

This example aggregates all stored math results (from `math::add` above) every 30 minutes.

<Tabs groupId="language" persist items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
iii.registerFunction({ id: 'math::aggregation' }, async () => {
    const results = await iii.trigger('state::list', { scope: 'math' });
    const values = results.map((r: { value: number }) => r.value);
    const sum = values.reduce((a: number, b: number) => a + b, 0);
    return { count: values.length, sum, average: sum / values.length };
});

iii.registerTrigger({
    type: 'cron',
    function_id: 'math::aggregation',
    config: { expression: '0 */30 * * * *' }, // every 30 minutes
});
```
</Tab>
<Tab value="Python">
```python
async def aggregation(_):
    results = await iii.trigger('state::list', {'scope': 'math'})
    values = [r['value'] for r in results]
    total = sum(values)
    return {'count': len(values), 'sum': total, 'average': total / len(values) if values else 0}

iii.register_function('math::aggregation', aggregation)

iii.register_trigger(
    type="cron",
    function_id="math::aggregation",
    config={"expression": "0 */30 * * * *"},  # every 30 minutes
)
```
</Tab>
<Tab value="Rust">
```rust
let iii_clone = iii.clone();
iii.register_function("math::aggregation", move |_| {
    let iii = iii_clone.clone();
    async move {
        let results = iii.trigger("state::list", json!({ "scope": "math" })).await?;
        let values: Vec<i64> = results.as_array()
            .map(|arr| arr.iter().filter_map(|r| r["value"].as_i64()).collect())
            .unwrap_or_default();
        let sum: i64 = values.iter().sum();
        let count = values.len();
        Ok(json!({ "count": count, "sum": sum, "average": sum as f64 / count as f64 }))
    }
});

iii.register_trigger(
    "cron",
    "math::aggregation",
    json!({ "expression": "0 */30 * * * *" }), // every 30 minutes
)?;
```
</Tab>
</Tabs>

#### State

State triggers fire when a value in state changes. This example posts to an external webhook
whenever an order's status is updated.

<Tabs groupId="language" persist items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
iii.registerFunction({ id: 'orders::webhook' }, async (event) => {
    await fetch(process.env.WEBHOOK_URL!, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ order_id: event.key, status: event.value }),
    });
});

iii.registerTrigger({
    type: 'state',
    function_id: 'orders::webhook',
    config: { scope: 'orders', key: 'status' },
});
```
</Tab>
<Tab value="Python">
```python
import httpx

async def webhook(event):
    async with httpx.AsyncClient() as client:
        await client.post(
            os.environ['WEBHOOK_URL'],
            json={'order_id': event['key'], 'status': event['value']},
        )

iii.register_function('orders::webhook', webhook)

iii.register_trigger(
    type="state",
    function_id="orders::webhook",
    config={"scope": "orders", "key": "status"},
)
```
</Tab>
<Tab value="Rust">
```rust
use iii_sdk::III;
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let url = std::env::var("III_BRIDGE_URL").unwrap_or_else(|_| "ws://127.0.0.1:49134".to_string());
    let iii = III::new(&url);
    iii.connect().await?;

    iii.register_function("orders::webhook", |event| async move {
        let client = reqwest::Client::new();
        let url = std::env::var("WEBHOOK_URL").expect("WEBHOOK_URL required");
        if let Err(e) = client.post(&url)
            .json(&json!({ "order_id": event["key"], "status": event["value"] }))
            .send()
            .await
        {
            return Ok(json!({ "error": e.to_string() }));
        }
        Ok(json!({}))
    });

    iii.register_trigger(
        "state",
        "orders::webhook",
        json!({ "scope": "orders", "key": "status" }),
    )?;

    Ok(())
}
```
</Tab>
</Tabs>

{/* TODO: Update this, enqueue is its entirely own thing */}

{/* <Callout type="info" title="Queue uses enqueue">
  Queue messaging uses `enqueue` — a built-in function, no trigger registration needed: `iii.trigger('enqueue', { topic: 'user.created', data: {...} })`. See the [Queue module](/docs/modules/module-queue) for details.
</Callout> */}

#### Removing Triggers

`registerTrigger()` returns a handle so you can remove the trigger later:

<Tabs groupId="language" persist items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
const t = iii.registerTrigger({
    type: 'http',
    function_id: 'fn::id',
    config: { api_path: '/ping', http_method: 'GET' }
})
t.unregister()
```
</Tab>
<Tab value="Python">
```python
t = iii.register_trigger(
    type='http',
    function_id='fn::id',
    config={'api_path': '/ping', 'http_method': 'GET'}
)
t.unregister()
```
</Tab>
<Tab value="Rust">
```rust
let t = iii.register_trigger(
    "http",
    "fn::id",
    json!({"api_path": "/ping", "http_method": "GET"}),
)?;
t.unregister();
```
</Tab>
</Tabs>

## Trigger Types

| Type | Fires when | Config fields | Module |
|------|-----------|---------------|--------|
| `http` | HTTP request received | `api_path`, `http_method` | HTTP |
| `cron` | Schedule fires | `expression` | Cron |
| `queue` | Message published to a topic | `topic` | Queue |
| `subscribe` | PubSub message on a topic | `topic` | PubSub |
| `state` | State value changes | `scope`, `key` | State |
| `stream` | Stream value changes | `stream_name`, `group_id`, `item_id` | Stream |
| `stream:join` | Client connects to stream | — | Stream |
| `stream:leave` | Client disconnects from stream | — | Stream |
| `log` | Log entry emitted | `level` | Observability |

## Cross-language triggering

Any Function can be Triggered anywhere regardless of language. The engine handles serialization and routing:

<Tabs groupId="language" persist items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
const result = await iii.trigger('math::add', { a: 2, b: 3 })
console.log(result) // { result: 5 }
```
</Tab>
<Tab value="Python">
```python
result = await iii.trigger('math::add', {'a': 2, 'b': 3})
print(result)  # {'result': 5}
```
</Tab>
<Tab value="Rust">
```rust
let result = iii.trigger("math::add", json!({"a": 2, "b": 3})).await?;
println!("{:?}", result); // {"result": 5}
```
</Tab>
</Tabs>

The triggering Function doesn't know what language the target is written in or where it's running.

Once a Function is registered, every other part of the system can discover and trigger it. See [Discovery](/docs/concepts/discovery) for how this works, including built-in functions the engine provides.

## init, Function, and Trigger Registration is Synchronous

The `init()` call returns immediately rather than returning a Promise. This is intentional.
Connection establishment happens asynchronously in the background.

This design avoids requiring developers to wrap initialization in an async function or await the SDK before
registering functions and triggers. Without this, every function and trigger definition would need to
wait on initialization, adding boilerplate to every file.

The trade-off: if code calls `shutdown()` immediately after `init()`, the connection may not yet
be established, resulting in an error like `WebSocket was closed before the connection was established`.
In practice this rarely matters — most applications register functions, respond to triggers, and run indefinitely.

## Function IDs

Function IDs use a `namespace::name` convention:

```
math::add
orders::process
notifications::send
```

<Callout title="engine prefix" type="warn">
The `engine::` prefix is reserved for internal engine functions.
</Callout>