---
title: 'Manage Shared State'
description: 'How to read, write, and update shared state across functions.'
---

## Goal

Use the State module to share data between Functions without a separate database.

## Steps

### 1. Enable the State module

```yaml
modules:
  - class: modules::state::StateModule
    config:
      adapter:
        class: modules::state::adapters::KvStore
        config:
          store_method: in_memory  # Options: in_memory, file_based
          # file_path: ./data/state_store.db  # required for file_based
```

### 2. Write state from a Function

<Tabs groupId="language" persist items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
import { init } from 'iii-sdk'

const iii = init('ws://localhost:49134')

iii.registerFunction(
  { id: 'users::create' },
  async (data) => {
    const user = { id: crypto.randomUUID(), ...data }

    await iii.trigger('state::set', {
      scope: 'users',
      key: user.id,
      value: user,
    })

    return user
  }
)
```
</Tab>
<Tab value="Python">
```python
import asyncio
import os
import signal
import uuid
from iii import III

iii = III(os.environ.get('III_BRIDGE_URL', 'ws://localhost:49134'))

async def create_user(data):
    user = {'id': str(uuid.uuid4()), **data}
    await iii.trigger('state::set', {
        'scope': 'users',
        'key': user['id'],
        'value': user,
    })
    return user

iii.register_function('users::create', create_user)

async def main():
    await iii.connect()
    stop = asyncio.Event()
    loop = asyncio.get_running_loop()
    for sig in (signal.SIGINT, signal.SIGTERM):
        loop.add_signal_handler(sig, stop.set)
    await stop.wait()

asyncio.run(main())
```
</Tab>
<Tab value="Rust">
```rust
use iii_sdk::III;
use serde_json::json;
use tokio::signal;
use uuid::Uuid;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let url = std::env::var("III_BRIDGE_URL").unwrap_or_else(|_| "ws://127.0.0.1:49134".to_string());
    let iii = III::new(&url);
    iii.connect().await?;

    iii.register_function("users::create", |data| async move {
        let id = Uuid::new_v4().to_string();
        let mut user = data.clone();
        user["id"] = json!(id);

        iii.trigger("state::set", json!({
            "scope": "users",
            "key": id,
            "value": user,
        })).await?;

        Ok(user)
    });

    signal::ctrl_c().await?;
    Ok(())
}
```
</Tab>
</Tabs>

### 3. Read state from another Function

<Tabs groupId="language" persist items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
iii.registerFunction(
  { id: 'users::get' },
  async (data) => {
    const user = await iii.trigger('state::get', {
      scope: 'users',
      key: data.id,
    })
    return user
  }
)
```
</Tab>
<Tab value="Python">
```python
async def get_user(data):
    user = await iii.trigger('state::get', {
        'scope': 'users',
        'key': data['id'],
    })
    return user

iii.register_function('users::get', get_user)
```
</Tab>
<Tab value="Rust">
```rust
iii.register_function("users::get", |data| async move {
    let key = data["id"].as_str().unwrap_or("");
    let user = iii.trigger("state::get", json!({
        "scope": "users",
        "key": key,
    })).await?;
    Ok(user)
});
```
</Tab>
</Tabs>

### 4. Atomic updates

Use `state::update` with update operations for safe concurrent modifications:

<Tabs groupId="language" persist items={["Node / TypeScript", "Python", "Rust"]}>
<Tab value="Node / TypeScript">
```typescript
await iii.trigger('state::update', {
  scope: 'users',
  key: userId,
  ops: [
    { type: 'set', path: 'lastLogin', value: new Date().toISOString() },
    { type: 'increment', path: 'loginCount', by: 1 },
  ],
})
```
</Tab>
<Tab value="Python">
```python
await iii.trigger('state::update', {
    'scope': 'users',
    'key': user_id,
    'ops': [
        {'type': 'set', 'path': 'lastLogin', 'value': datetime.now(timezone.utc).isoformat()},
        {'type': 'increment', 'path': 'loginCount', 'by': 1},
    ],
})
```
</Tab>
<Tab value="Rust">
```rust
iii.trigger("state::update", json!({
    "scope": "users",
    "key": user_id,
    "ops": [
        { "type": "set", "path": "lastLogin", "value": chrono::Utc::now().to_rfc3339() },
        { "type": "increment", "path": "loginCount", "by": 1 },
    ],
})).await?;
```
</Tab>
</Tabs>

## Result

State is shared across all Functions in the system. Any Function can read or write to any scope/key pair. The Engine handles consistency and persistence based on the configured adapter.

<Callout title="Production adapters" type="info">
  The `memory` adapter is for development only. For production, use a persistent adapter like Redis. See the [State module reference](/docs/modules/module-state).
</Callout>
