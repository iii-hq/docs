---
title: 'Manage Shared State'
description: 'How to read, write, and update shared state across functions.'
---

## Goal

Use the State module to share data between Functions without a separate database.

## Steps

### 1. Enable the State module

```yaml
modules:
  state:
    adapter: memory
```

### 2. Write state from a Function

<Tabs items={["TypeScript", "Python", "Rust"]}>
<Tab value="TypeScript">
```typescript
import { init } from 'iii-sdk'

const iii = init('ws://localhost:49134')

iii.registerFunction(
  { id: 'users::create' },
  async (data) => {
    const user = { id: crypto.randomUUID(), ...data }

    await iii.trigger('state::set', {
      scope: 'users',
      key: user.id,
      data: user,
    })

    return user
  }
)
```
</Tab>
<Tab value="Python">
```python
import asyncio, uuid
from iii import III

async def main():
    iii = III('ws://localhost:49134')

    async def create_user(data):
        user = {'id': str(uuid.uuid4()), **data}

        await iii.trigger('state::set', {
            'scope': 'users',
            'key': user['id'],
            'data': user,
        })

        return user

    iii.register_function('users::create', create_user)
    await iii.connect()

asyncio.run(main())
```
</Tab>
<Tab value="Rust">
```rust
use iii_sdk::III;
use serde_json::json;
use uuid::Uuid;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let iii = III::new("ws://127.0.0.1:49134");
    iii.connect().await?;

    iii.register_function("users::create", |data| async move {
        let id = Uuid::new_v4().to_string();
        let mut user = data.clone();
        user["id"] = json!(id);

        iii.trigger("state::set", json!({
            "scope": "users",
            "key": id,
            "data": user,
        })).await?;

        Ok(user)
    });

    loop { tokio::time::sleep(std::time::Duration::from_secs(60)).await; }
}
```
</Tab>
</Tabs>

### 3. Read state from another Function

<Tabs items={["TypeScript", "Python", "Rust"]}>
<Tab value="TypeScript">
```typescript
iii.registerFunction(
  { id: 'users::get' },
  async (data) => {
    const user = await iii.trigger('state::get', {
      scope: 'users',
      key: data.id,
    })
    return user
  }
)
```
</Tab>
<Tab value="Python">
```python
async def get_user(data):
    user = await iii.trigger('state::get', {
        'scope': 'users',
        'key': data['id'],
    })
    return user

iii.register_function('users::get', get_user)
```
</Tab>
<Tab value="Rust">
```rust
iii.register_function("users::get", |data| async move {
    let key = data["id"].as_str().unwrap_or("");
    let user = iii.trigger("state::get", json!({
        "scope": "users",
        "key": key,
    })).await?;
    Ok(user)
});
```
</Tab>
</Tabs>

### 4. Atomic updates

Use `state::update` with update operations for safe concurrent modifications:

<Tabs items={["TypeScript", "Python", "Rust"]}>
<Tab value="TypeScript">
```typescript
await iii.trigger('state::update', {
  scope: 'users',
  key: userId,
  ops: [
    { type: 'set', path: 'lastLogin', value: new Date().toISOString() },
    { type: 'increment', path: 'loginCount', by: 1 },
  ],
})
```
</Tab>
<Tab value="Python">
```python
await iii.trigger('state::update', {
    'scope': 'users',
    'key': user_id,
    'ops': [
        {'type': 'set', 'path': 'lastLogin', 'value': datetime.now(timezone.utc).isoformat()},
        {'type': 'increment', 'path': 'loginCount', 'by': 1},
    ],
})
```
</Tab>
<Tab value="Rust">
```rust
iii.trigger("state::update", json!({
    "scope": "users",
    "key": user_id,
    "ops": [
        { "type": "set", "path": "lastLogin", "value": chrono::Utc::now().to_rfc3339() },
        { "type": "increment", "path": "loginCount", "by": 1 },
    ],
})).await?;
```
</Tab>
</Tabs>

## Result

State is shared across all Functions in the system. Any Function can read or write to any scope/key pair. The Engine handles consistency and persistence based on the configured adapter.

<Callout title="Production adapters" type="info">
  The `memory` adapter is for development only. For production, use a persistent adapter like Redis. See the [State module reference](/docs/modules/module-state).
</Callout>
