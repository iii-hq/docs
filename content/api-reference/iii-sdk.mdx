---
title: "SDK Reference"
description: "Complete API reference for the iii SDK across TypeScript, Python, and Rust."
---

## Initialization

The SDK connects your application to the iii engine over WebSocket.

<Tabs items={["TypeScript", "Python", "Rust"]}>
<Tab value="TypeScript">
```typescript
import { init } from '@iii-dev/sdk'

const iii = init('ws://localhost:49134', {
  workerName: 'my-worker',
  invocationTimeoutMs: 30000,
})
```
</Tab>
<Tab value="Python">
```python
from iii import III

iii = III('ws://localhost:49134')
await iii.connect()
```
</Tab>
<Tab value="Rust">
```rust
use iii::III;

let iii = III::new("ws://localhost:49134");
iii.connect().await?;
```
</Tab>
</Tabs>

<Callout title="Default port" type="info">
  The iii engine listens on `ws://localhost:49134` by default when running locally.
</Callout>

### InitOptions (TypeScript)

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `workerName` | `string` | `undefined` | Name for this worker instance |
| `enableMetricsReporting` | `boolean` | `false` | Enable OpenTelemetry metrics |
| `invocationTimeoutMs` | `number` | `30000` | Default timeout for `trigger()` calls |
| `reconnectionConfig` | `Partial<ReconnectionConfig>` | See below | Reconnection behavior |
| `otel` | `OtelConfig` | `undefined` | OpenTelemetry configuration |

### ReconnectionConfig

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `initialDelayMs` | `number` | `1000` | Initial reconnection delay |
| `maxDelayMs` | `number` | `30000` | Maximum reconnection delay |
| `backoffMultiplier` | `number` | `2` | Exponential backoff multiplier |
| `jitterFactor` | `number` | `0.3` | Jitter factor for delay randomization |
| `maxRetries` | `number` | `-1` | Maximum retries (`-1` for unlimited) |

---

## trigger()

Triggers a function and waits for the result. This is the primary way to invoke a function synchronously.

<Tabs items={["TypeScript", "Python", "Rust"]}>
<Tab value="TypeScript">
```typescript
const result = await iii.trigger<{ name: string }, { id: string }>(
  'users::create',
  { name: 'Alice' }
)
```
</Tab>
<Tab value="Python">
```python
result = await iii.trigger('users::create', {'name': 'Alice'})
```
</Tab>
<Tab value="Rust">
```rust
let result = iii.trigger("users::create", json!({"name": "Alice"})).await?;
```
</Tab>
</Tabs>

<ResponseField name="trigger" type="<TInput, TOutput>(function_id: string, data: TInput, timeoutMs?: number) => Promise<TOutput>" required>
  Triggers a registered function and returns its result.

  <AccordionGroup>
    <Accordion iconName="Settings" title="Parameters" description="">
      <ResponseField name="function_id" type="string" required>
        The function identifier (e.g., `'users::create'`, `'state::set'`).
      </ResponseField>
      <ResponseField name="data" type="TInput" required>
        The payload to pass to the function.
      </ResponseField>
      <ResponseField name="timeoutMs" type="number">
        Timeout in milliseconds. Defaults to `invocationTimeoutMs` from init (30000ms).
      </ResponseField>
    </Accordion>
    <Accordion iconName="ArrowUpRight" title="Returns" description="">
      <ResponseField name="result" type="Promise<TOutput>">
        The result returned by the function handler.
      </ResponseField>
    </Accordion>
  </AccordionGroup>
</ResponseField>

<Callout title="Backward compatibility" type="info">
  `call()` is available as an alias for `trigger()` for backward compatibility.
</Callout>

---

## triggerVoid()

Triggers a function without waiting for a result (fire-and-forget).

<Tabs items={["TypeScript", "Python", "Rust"]}>
<Tab value="TypeScript">
```typescript
iii.triggerVoid('notifications::send', {
  to: 'alice@example.com',
  message: 'Welcome!',
})
```
</Tab>
<Tab value="Python">
```python
iii.trigger_void('notifications::send', {
    'to': 'alice@example.com',
    'message': 'Welcome!',
})
```
</Tab>
<Tab value="Rust">
```rust
iii.trigger_void("notifications::send", json!({
    "to": "alice@example.com",
    "message": "Welcome!",
}))?;
```
</Tab>
</Tabs>

<ResponseField name="triggerVoid" type="<TInput>(function_id: string, data: TInput) => void" required>
  Triggers a function without waiting for a response. In Rust, returns `Result<(), IIIError>` since serialization can fail.

  <AccordionGroup>
    <Accordion iconName="Settings" title="Parameters" description="">
      <ResponseField name="function_id" type="string" required>
        The function identifier.
      </ResponseField>
      <ResponseField name="data" type="TInput" required>
        The payload to pass to the function.
      </ResponseField>
    </Accordion>
  </AccordionGroup>
</ResponseField>

<Callout title="Backward compatibility" type="info">
  `callVoid()` (TypeScript) / `call_void()` (Python/Rust) are available as aliases.
</Callout>

---

## registerFunction()

Registers a function with the iii engine. Once registered, the function can be triggered by any other component in the system.

<Tabs items={["TypeScript", "Python", "Rust"]}>
<Tab value="TypeScript">
```typescript
const ref = iii.registerFunction(
  { function_path: 'users::create' },
  async (data: { name: string }) => {
    return { id: crypto.randomUUID(), name: data.name }
  }
)
```
</Tab>
<Tab value="Python">
```python
async def create_user(data):
    return {'id': str(uuid.uuid4()), 'name': data['name']}

ref = iii.register_function('users::create', create_user)
```
</Tab>
<Tab value="Rust">
```rust
iii.register_function("users::create", |data: Value| async move {
    Ok(json!({"id": Uuid::new_v4().to_string(), "name": data["name"]}))
});
```
</Tab>
</Tabs>

<ResponseField name="registerFunction" type="(func: RegisterFunctionInput, handler: RemoteFunctionHandler) => FunctionRef" required>
  Registers a function handler with the engine.

  <AccordionGroup>
    <Accordion iconName="Settings" title="Parameters" description="">
      <ResponseField name="func" type="RegisterFunctionInput" required>
        The function registration input.

        <Expandable title="RegisterFunctionInput">
          <ResponseField name="function_path" type="string" required>
            The function identifier (e.g., `'users::create'`).
          </ResponseField>
          <ResponseField name="description" type="string">
            Description of the function.
          </ResponseField>
        </Expandable>
      </ResponseField>
      <ResponseField name="handler" type="RemoteFunctionHandler" required>
        An async function that receives the input data and returns a result.
      </ResponseField>
    </Accordion>
    <Accordion iconName="ArrowUpRight" title="Returns" description="">
      <ResponseField name="FunctionRef" type="FunctionRef">
        A reference object for managing the registered function.

        ```typescript
        type FunctionRef = {
          id: string
          unregister: () => void
        }
        ```
      </ResponseField>
    </Accordion>
  </AccordionGroup>
</ResponseField>

---

## registerTrigger()

Registers a trigger that invokes a function when a specific event occurs (HTTP request, cron schedule, queue message, etc.).

<Tabs items={["TypeScript", "Python", "Rust"]}>
<Tab value="TypeScript">
```typescript
const trigger = iii.registerTrigger({
  trigger_type: 'http',
  function_id: 'users::create',
  config: { method: 'POST', path: '/users' },
})
```
</Tab>
<Tab value="Python">
```python
trigger = iii.register_trigger(
    type='http',
    function_id='users::create',
    config={'method': 'POST', 'path': '/users'},
)
```
</Tab>
<Tab value="Rust">
```rust
let trigger = iii.register_trigger(
    "http",
    "users::create",
    json!({"method": "POST", "path": "/users"}),
)?;
```
</Tab>
</Tabs>

<ResponseField name="registerTrigger" type="(trigger: RegisterTriggerInput) => Trigger" required>
  Registers a new trigger.

  <AccordionGroup>
    <Accordion iconName="Settings" title="Parameters" description="">
      <ResponseField name="trigger" type="RegisterTriggerInput" required>
        The trigger configuration.

        <Expandable title="RegisterTriggerInput">
          <ResponseField name="trigger_type" type="string" required>
            The trigger type (e.g., `'http'`, `'cron'`, `'queue'`).
          </ResponseField>
          <ResponseField name="function_id" type="string" required>
            The function to invoke when the trigger fires.
          </ResponseField>
          <ResponseField name="config" type="object" required>
            Trigger-type-specific configuration.
          </ResponseField>
        </Expandable>
      </ResponseField>
    </Accordion>
    <Accordion iconName="ArrowUpRight" title="Returns" description="">
      <ResponseField name="Trigger" type="Trigger">
        A trigger object that can be used to unregister the trigger.

        ```typescript
        type Trigger = {
          unregister(): void
        }
        ```
      </ResponseField>
    </Accordion>
  </AccordionGroup>
</ResponseField>

---

## registerTriggerType()

Registers a custom trigger type with the engine. This allows you to define new ways to invoke functions beyond the built-in types (HTTP, cron, queue).

<Tabs items={["TypeScript", "Python", "Rust"]}>
<Tab value="TypeScript">
```typescript
iii.registerTriggerType<WebhookConfig>(
  { id: 'webhook', description: 'External webhook trigger' },
  {
    async registerTrigger(config) {
      // set up the webhook listener
    },
    async unregisterTrigger(config) {
      // tear down the webhook listener
    },
  }
)
```
</Tab>
<Tab value="Python">
```python
iii.register_trigger_type(
    id='webhook',
    description='External webhook trigger',
    handler=WebhookHandler(),
)
```
</Tab>
<Tab value="Rust">
```rust
iii.register_trigger_type("webhook", "External webhook trigger", WebhookHandler);
```
</Tab>
</Tabs>

<ResponseField name="registerTriggerType" type="<TConfig>(triggerType: RegisterTriggerTypeInput, handler: TriggerHandler<TConfig>) => void" required>
  Registers a custom trigger type.

  <AccordionGroup>
    <Accordion iconName="Settings" title="Parameters" description="">
      <ResponseField name="triggerType" type="RegisterTriggerTypeInput" required>
        <Expandable title="RegisterTriggerTypeInput">
          <ResponseField name="id" type="string" required>
            Unique identifier for this trigger type.
          </ResponseField>
          <ResponseField name="description" type="string">
            Human-readable description.
          </ResponseField>
        </Expandable>
      </ResponseField>
      <ResponseField name="handler" type="TriggerHandler<TConfig>" required>
        Implements `registerTrigger` and `unregisterTrigger` lifecycle methods.

        ```typescript
        type TriggerHandler<TConfig> = {
          registerTrigger(config: TriggerConfig<TConfig>): Promise<void>
          unregisterTrigger(config: TriggerConfig<TConfig>): Promise<void>
        }
        ```
      </ResponseField>
    </Accordion>
  </AccordionGroup>
</ResponseField>

---

## unregisterTriggerType()

Removes a previously registered trigger type.

```typescript
iii.unregisterTriggerType({ id: 'webhook' })
```

<ResponseField name="unregisterTriggerType" type="(triggerType: RegisterTriggerTypeInput) => void" required>
  Unregisters a trigger type by its ID.
</ResponseField>

---

## listFunctions()

Returns all functions currently registered with the engine.

<Tabs items={["TypeScript", "Python", "Rust"]}>
<Tab value="TypeScript">
```typescript
const functions = await iii.listFunctions()
```
</Tab>
<Tab value="Python">
```python
functions = await iii.list_functions()
```
</Tab>
<Tab value="Rust">
```rust
let functions = iii.list_functions().await?;
```
</Tab>
</Tabs>

<ResponseField name="listFunctions" type="() => Promise<FunctionInfo[]>" required>
  Lists all registered functions.

  <AccordionGroup>
    <Accordion iconName="ArrowUpRight" title="Returns" description="">
      <ResponseField name="functions" type="FunctionInfo[]">
        Array of function metadata objects.

        ```typescript
        type FunctionInfo = {
          id: string
          description?: string
          worker_id?: string
        }
        ```
      </ResponseField>
    </Accordion>
  </AccordionGroup>
</ResponseField>

---

## createStream()

Registers a custom stream implementation, overriding the engine's default stream behavior.

```typescript
iii.createStream<ChatMessage>('chat', myCustomStreamImpl)
```

<ResponseField name="createStream" type="<TData>(streamName: string, stream: IStream<TData>) => void" required>
  Registers a stream implementation.

  <AccordionGroup>
    <Accordion iconName="Settings" title="Parameters" description="">
      <ResponseField name="streamName" type="string" required>
        The name of the stream.
      </ResponseField>
      <ResponseField name="stream" type="IStream<TData>" required>
        The stream implementation. See [Stream module](/docs/modules/module-stream) for the `IStream` interface.
      </ResponseField>
    </Accordion>
  </AccordionGroup>
</ResponseField>

---

## Event Callbacks

### onFunctionsAvailable()

Receives the current function list whenever the engine announces changes.

```typescript
const unsubscribe = iii.onFunctionsAvailable((functions) => {
  console.log('Available functions:', functions.map(f => f.id))
})
```

### onLog()

Receives OpenTelemetry log events from the engine. Useful for building custom log UIs or forwarding logs.

```typescript
const unsubscribe = iii.onLog(
  (log) => console.log(`[${log.severity_text}] ${log.body}`),
  { level: 'info' }
)
```

| Level | Description |
|-------|-------------|
| `'all'` | All log events (default) |
| `'trace'` | Trace and above |
| `'debug'` | Debug and above |
| `'info'` | Info and above |
| `'warn'` | Warn and above |
| `'error'` | Error and above |
| `'fatal'` | Fatal only |

---

## Lifecycle

### shutdown()

Gracefully shuts down the SDK, cleaning up WebSocket connections, pending invocations, and OpenTelemetry resources.

<Tabs items={["TypeScript", "Python", "Rust"]}>
<Tab value="TypeScript">
```typescript
await iii.shutdown()
```
</Tab>
<Tab value="Python">
```python
await iii.shutdown()
```
</Tab>
<Tab value="Rust">
```rust
iii.shutdown_async().await;
```
</Tab>
</Tabs>

---

## Connection State

Monitor and react to connection state changes.

```typescript
const state = iii.getConnectionState()

const unsubscribe = iii.onConnectionStateChange((state) => {
  console.log('Connection:', state)
})
```

| State | Description |
|-------|-------------|
| `'disconnected'` | Not connected |
| `'connecting'` | Initial connection in progress |
| `'connected'` | Connected and ready |
| `'reconnecting'` | Lost connection, attempting to reconnect |
| `'failed'` | Reconnection attempts exhausted |

---

## Types

### ApiRequest

Received by functions registered as HTTP trigger handlers.

```typescript
type ApiRequest<TBody = unknown> = {
  path_params: Record<string, string>
  query_params: Record<string, string | string[]>
  body: TBody
  headers: Record<string, string | string[]>
  method: string
}
```

### ApiResponse

Returned by HTTP trigger handler functions.

```typescript
type ApiResponse<TStatus extends number = number, TBody = string | Buffer | Record<string, unknown>> = {
  status_code: TStatus
  headers?: Record<string, string>
  body: TBody
}
```

---

## Sub-modules

The SDK exports additional modules for specific functionality:

| Import | Description | Docs |
|--------|-------------|------|
| `@iii-dev/sdk/stream` | Stream data types and interfaces | [Stream module](/docs/modules/module-stream) |
| `@iii-dev/sdk/state` | State management types and interfaces | [State module](/docs/modules/module-state) |
| `@iii-dev/sdk/telemetry` | OpenTelemetry utilities | [Observability module](/docs/modules/module-observability) |
