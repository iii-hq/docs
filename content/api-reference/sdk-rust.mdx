---
title: "Rust SDK"
description: "API reference for the iii SDK for Rust."
---

## Installation

```toml
[dependencies]
iii-sdk = "0.2"
```

Enable OpenTelemetry support with the `otel` feature:

```toml
[dependencies]
iii-sdk = { version = "0.2", features = ["otel"] }
```

## Initialization

The Rust SDK requires an explicit `connect().await` call.

```rust
use iii_sdk::{III, get_context};
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let iii = III::new("ws://127.0.0.1:49134");
    iii.connect().await?;

    // ... register functions and triggers

    loop {
        tokio::time::sleep(std::time::Duration::from_secs(60)).await;
    }
}
```

## Methods

### register_function

<ResponseField name="register_function" type="fn(&self, id: impl Into&lt;String&gt;, handler: F)" required>
  Registers a function. The handler receives `serde_json::Value` and returns `Result&lt;Value, IIIError&gt;`.

  <AccordionGroup>
    <Accordion iconName="Code" title="Example" description="">
      ```rust
      iii.register_function("greet", |input| async move {
          let name = input["name"].as_str().unwrap_or("world");
          Ok(json!({ "message": format!("Hello, {}!", name) }))
      });
      ```
    </Accordion>
  </AccordionGroup>
</ResponseField>

### register_function_with_description

<ResponseField name="register_function_with_description" type="fn(&self, id: impl Into&lt;String&gt;, description: impl Into&lt;String&gt;, handler: F)" required>
  Same as `register_function` but attaches a human-readable description.

  <AccordionGroup>
    <Accordion iconName="Code" title="Example" description="">
      ```rust
      iii.register_function_with_description(
          "greet",
          "Greets a user by name",
          |input| async move {
              let name = input["name"].as_str().unwrap_or("world");
              Ok(json!({ "message": format!("Hello, {}!", name) }))
          },
      );
      ```
    </Accordion>
  </AccordionGroup>
</ResponseField>

### register_function_with

<ResponseField name="register_function_with" type="fn(&self, message: RegisterFunctionMessage, handler: F)" required>
  Low-level registration with full control over the `RegisterFunctionMessage` fields (`id`, `description`, `request_format`, `response_format`, `metadata`).
</ResponseField>

### register_trigger

<ResponseField name="register_trigger" type="fn(&self, trigger_type: impl Into&lt;String&gt;, function_id: impl Into&lt;String&gt;, config: impl Serialize) => Result&lt;Trigger, IIIError&gt;" required>
  Binds a trigger to a function. Returns a `Trigger` whose `unregister()` method removes the binding.

  <AccordionGroup>
    <Accordion iconName="Code" title="Example" description="">
      ```rust
      iii.register_trigger("http", "greet", json!({
          "api_path": "/greet",
          "http_method": "GET",
      }))?;
      ```
    </Accordion>
  </AccordionGroup>
</ResponseField>

### trigger

<ResponseField name="trigger" type="async fn(&self, function_id: &str, data: impl Serialize) => Result&lt;Value, IIIError&gt;" required>
  Invokes a remote function with a 30-second default timeout.

  <AccordionGroup>
    <Accordion iconName="Code" title="Example" description="">
      ```rust
      let result = iii.trigger("queue::enqueue", json!({
          "topic": "user.created",
          "data": {"user_id": "123"},
      })).await?;
      ```
    </Accordion>
  </AccordionGroup>
</ResponseField>

### trigger_with_timeout

<ResponseField name="trigger_with_timeout" type="async fn(&self, function_id: &str, data: Value, timeout: Duration) => Result&lt;Value, IIIError&gt;" required>
  Invokes a remote function with a custom timeout.
</ResponseField>

### trigger_void

<ResponseField name="trigger_void" type="fn(&self, function_id: &str, data: impl Serialize) => Result&lt;(), IIIError&gt;" required>
  Fire-and-forget invocation. Sends the message without waiting for a response.
</ResponseField>

<Callout type="warn" title="Deprecated methods">
  `call`, `call_with_timeout`, and `call_void` are deprecated. Use `trigger`, `trigger_with_timeout`, and `trigger_void` instead.
</Callout>

### shutdown_async

<ResponseField name="shutdown_async" type="async fn(&self)" required>
  Stops the connection loop and sends a shutdown signal. When the `otel` feature is enabled, flushes all pending spans, metrics, and logs before returning.
</ResponseField>

### register_trigger_type

<ResponseField name="register_trigger_type" type="fn(&self, id: impl Into&lt;String&gt;, description: impl Into&lt;String&gt;, handler: H)" required>
  Registers a custom trigger type. `H` must implement the `TriggerHandler` trait:

  ```rust
  #[async_trait]
  pub trait TriggerHandler: Send + Sync {
      async fn register_trigger(&self, config: TriggerConfig) -> Result<(), IIIError>;
      async fn unregister_trigger(&self, config: TriggerConfig) -> Result<(), IIIError>;
  }
  ```
</ResponseField>

### unregister_trigger_type

<ResponseField name="unregister_trigger_type" type="fn(&self, id: impl Into&lt;String&gt;)" required>
  Unregisters a trigger type by removing it from the local registry.
</ResponseField>

### on_functions_available

<ResponseField name="on_functions_available" type="fn(&self, callback: FunctionsAvailableCallback) => Result&lt;FunctionsAvailableGuard, IIIError&gt;" required>
  Subscribes to function availability events. Drop the returned `FunctionsAvailableGuard` to unsubscribe.
</ResponseField>

## Streams

The Rust SDK provides atomic stream updates via the `Streams` helper:

```rust
use iii_sdk::{Streams, UpdateOp};
use serde_json::json;

let streams = Streams::new(iii.clone());

let result = streams.update(
    "my-stream::group-1::item-1",
    vec![
        UpdateOp::increment("counter", 1),
        UpdateOp::set("status", json!("active")),
    ],
).await?;

println!("Old: {:?}, New: {:?}", result.old_value, result.new_value);
```

### UpdateOp variants

| Constructor | Description |
|---|---|
| `UpdateOp::set(path, value)` | Set a field to a value |
| `UpdateOp::increment(path, by)` | Increment a numeric field |
| `UpdateOp::decrement(path, by)` | Decrement a numeric field |
| `UpdateOp::remove(path)` | Remove a field |
| `UpdateOp::merge(path, value)` | Deep-merge an object into a field |

You can also use the `UpdateBuilder` for a fluent API:

```rust
use iii_sdk::UpdateBuilder;

let result = UpdateBuilder::new(&streams, "orders::user-1::order-1")
    .increment("total", 50)
    .set("status", json!("processing"))
    .execute()
    .await?;
```

## Error Handling

All fallible operations return `Result<T, IIIError>`. Common variants:

| Variant | Description |
|---|---|
| `IIIError::NotConnected` | WebSocket is not open |
| `IIIError::Timeout` | Invocation timed out |
| `IIIError::InvocationFailed { code, message }` | Remote function returned an error |
| `IIIError::Serialization(err)` | JSON serialization failed |

## Types

### Re-exports from `iii_sdk`

```rust
use iii_sdk::{
    III,
    Context, get_context, with_context,
    IIIError,
    FunctionInfo, WorkerInfo, WorkerMetadata,
    TriggerInfo,
    Logger, LoggerInvoker,
    Trigger, TriggerConfig, TriggerHandler,
    Streams, UpdateBuilder,
    Value,  // re-export of serde_json::Value
};

use iii_sdk::types::{
    ApiRequest, ApiResponse,
    FieldPath, StreamUpdateInput, UpdateOp, UpdateResult,
};

use iii_sdk::protocol::{
    Message, RegisterFunctionMessage,
    RegisterTriggerMessage, RegisterTriggerTypeMessage, ErrorBody,
};
```

### OpenTelemetry (behind `otel` feature)

```rust
use iii_sdk::{
    init_otel, shutdown_otel, flush_otel,
    get_tracer, get_meter, is_initialized,
    with_span, SpanKind, SpanStatus,
    OtelConfig, ReconnectionConfig,
};

use iii_sdk::{
    current_trace_id, current_span_id,
    inject_traceparent, inject_baggage,
    extract_context, extract_traceparent, extract_baggage,
    get_baggage_entry, set_baggage_entry, get_all_baggage,
    remove_baggage_entry,
};
```

## Context

```rust
use iii_sdk::get_context;

let ctx = get_context();
ctx.logger.info("Processing started", None);
ctx.logger.warn("Low memory", Some(json!({ "available_mb": 128 })));
```

The `get_context()` function returns the current `Context` (with `logger`) from within a function handler. The logger sends log events to the engine via `engine::log::*` functions.
