---
title: "Python SDK"
description: "API reference for the iii SDK for Python."
---

## Installation

```bash
pip install iii-sdk
```

The package is imported as `iii`:

```python
from iii import III, InitOptions, get_context, ApiRequest, ApiResponse
```

## Initialization

The Python SDK requires an explicit `connect()` call to establish the WebSocket connection.

```python
import asyncio
from iii import III, InitOptions

iii = III(
    address="ws://localhost:49134",
    options=InitOptions(worker_name="my-worker"),
)

async def main():
    await iii.connect()
    # ... register functions and triggers
    while True:
        await asyncio.sleep(60)

asyncio.run(main())
```

<ResponseField name="III" type="class" required>
  The main SDK client.

  <AccordionGroup>
    <Accordion iconName="Settings" title="Constructor" description="">
      <ResponseField name="address" type="str" required>
        WebSocket URL of the iii Engine.
      </ResponseField>
      <ResponseField name="options" type="InitOptions | None">
        <Expandable title="InitOptions">
          <ResponseField name="worker_name" type="str | None">
            Display name for this worker. Defaults to `hostname:pid`.
          </ResponseField>
        </Expandable>
      </ResponseField>
    </Accordion>
  </AccordionGroup>
</ResponseField>

## Methods

### connect

<ResponseField name="connect" type="async () => None" required>
  Establishes the WebSocket connection and re-registers all previously registered functions, triggers, and services. Handles automatic reconnection on disconnect.
</ResponseField>

### shutdown

<ResponseField name="shutdown" type="async () => None" required>
  Disconnects from the engine and cancels background tasks.
</ResponseField>

### register_function

<ResponseField name="register_function" type="(path: str, handler: Callable, description: str | None = None) => None" required>
  Registers a function with the engine.

  <AccordionGroup>
    <Accordion iconName="Settings" title="Parameters" description="">
      <ResponseField name="path" type="str" required>
        Unique function identifier.
      </ResponseField>
      <ResponseField name="handler" type="Callable[[Any], Awaitable[Any]]" required>
        Async function that processes the invocation payload.
      </ResponseField>
      <ResponseField name="description" type="str | None">
        Human-readable description.
      </ResponseField>
    </Accordion>
    <Accordion iconName="Code" title="Example" description="">
      ```python
      async def greet(data):
          return {"message": f"Hello, {data['name']}!"}

      iii.register_function("greet", greet, description="Greets a user")
      ```
    </Accordion>
  </AccordionGroup>
</ResponseField>

### register_trigger

<ResponseField name="register_trigger" type="(type: str, function_id: str, config: Any) => Trigger" required>
  Binds a trigger configuration to a registered function.

  <AccordionGroup>
    <Accordion iconName="Settings" title="Parameters" description="">
      <ResponseField name="type" type="str" required>
        Trigger type (e.g. `http`, `queue`, `cron`).
      </ResponseField>
      <ResponseField name="function_id" type="str" required>
        ID of the function to invoke.
      </ResponseField>
      <ResponseField name="config" type="Any" required>
        Trigger-specific configuration.
      </ResponseField>
    </Accordion>
    <Accordion iconName="ArrowUpRight" title="Returns" description="">
      <ResponseField name="Trigger" type="Trigger">
        Object with an `unregister()` method.
      </ResponseField>
    </Accordion>
    <Accordion iconName="Code" title="Example" description="">
      ```python
      iii.register_trigger(
          type="http",
          function_id="greet",
          config={"api_path": "/greet", "http_method": "GET"},
      )
      ```
    </Accordion>
  </AccordionGroup>
</ResponseField>

### trigger

<ResponseField name="trigger" type="async (path: str, data: Any, timeout: float = 30.0) => Any" required>
  Invokes a remote function and waits for the result.

  <AccordionGroup>
    <Accordion iconName="Settings" title="Parameters" description="">
      <ResponseField name="path" type="str" required>
        Function ID to invoke.
      </ResponseField>
      <ResponseField name="data" type="Any" required>
        Payload to pass to the function.
      </ResponseField>
      <ResponseField name="timeout" type="float">
        Timeout in seconds. Default `30.0`.
      </ResponseField>
    </Accordion>
    <Accordion iconName="Code" title="Example" description="">
      ```python
      result = await iii.trigger("queue::enqueue", {
          "topic": "user.created",
          "data": {"user_id": "123"},
      })
      ```
    </Accordion>
  </AccordionGroup>
</ResponseField>

### trigger_void

<ResponseField name="trigger_void" type="(path: str, data: Any) => None" required>
  Fire-and-forget invocation. No response is expected.
</ResponseField>

<Callout type="warn" title="Deprecated methods">
  `call` and `call_void` are deprecated. Use `trigger` and `trigger_void` instead.
</Callout>

### create_stream

<ResponseField name="create_stream" type="(stream_name: str, stream: IStream) => None" required>
  Registers a custom stream implementation. This registers `{stream_name}::get`, `::set`, `::delete`, `::list`, `::list_groups`, and `::update` functions.

  <AccordionGroup>
    <Accordion iconName="Code" title="Example" description="">
      ```python
      from iii.stream import IStream, StreamGetInput, StreamSetInput

      class MyStream(IStream):
          async def get(self, input: StreamGetInput):
              ...
          async def set(self, input: StreamSetInput):
              ...
          # ... implement delete, list, list_groups, update

      iii.create_stream("todos", MyStream())
      ```
    </Accordion>
  </AccordionGroup>
</ResponseField>

### on_functions_available

<ResponseField name="on_functions_available" type="(callback: Callable[[list[FunctionInfo]], None]) => Callable[[], None]" required>
  Subscribes to function availability events. Returns an unsubscribe function.
</ResponseField>

### list_functions

<ResponseField name="list_functions" type="async () => list[FunctionInfo]" required>
  Lists all functions registered with the engine.
</ResponseField>

### list_workers

<ResponseField name="list_workers" type="async () => list[WorkerInfo]" required>
  Lists all connected workers.
</ResponseField>

### register_trigger_type

<ResponseField name="register_trigger_type" type="(id: str, description: str, handler: TriggerHandler) => None" required>
  Registers a custom trigger type.

  <AccordionGroup>
    <Accordion iconName="Settings" title="Parameters" description="">
      <ResponseField name="id" type="str" required>
        Unique trigger type identifier.
      </ResponseField>
      <ResponseField name="description" type="str" required>
        Human-readable description.
      </ResponseField>
      <ResponseField name="handler" type="TriggerHandler" required>
        Must implement `register_trigger(config: TriggerConfig)` and `unregister_trigger(config: TriggerConfig)` async methods.
      </ResponseField>
    </Accordion>
  </AccordionGroup>
</ResponseField>

### unregister_trigger_type

<ResponseField name="unregister_trigger_type" type="(id: str) => None" required>
  Unregisters a trigger type.
</ResponseField>

## Types

```python
from iii import ApiRequest, ApiResponse

class ApiRequest(BaseModel, Generic[TInput]):
    path_params: dict[str, str]          # alias: pathParams
    query_params: dict[str, str | list[str]]  # alias: queryParams
    body: Any | None = None
    headers: dict[str, str | list[str]]
    method: str = "GET"

class ApiResponse(BaseModel, Generic[TOutput]):
    status_code: int    # alias: statusCode
    body: Any
    headers: dict[str, str] = {}
```

<Callout title="Pydantic aliases" type="info">
  `ApiRequest` and `ApiResponse` use Pydantic `populate_by_name=True`, so both `status_code` and `statusCode` work when constructing instances.
</Callout>

### Stream Types

```python
from iii.stream import (
    IStream,
    StreamGetInput,
    StreamSetInput,
    StreamSetResult,
    StreamDeleteInput,
    StreamListInput,
    StreamListGroupsInput,
    StreamUpdateInput,
    UpdateOp,
    UpdateSet,
    UpdateIncrement,
    UpdateDecrement,
    UpdateRemove,
    UpdateMerge,
)
```

### Other Exports

```python
from iii import (
    FunctionInfo,
    WorkerInfo,
    WorkerStatus,
    FunctionsAvailableCallback,
    RemoteFunctionHandler,
    Logger,
    Context,
    configure_logging,
)
```

## Context

```python
from iii import get_context

ctx = get_context()
ctx.logger.info("Processing started")
```

The `get_context()` function returns the current `Context` (with `logger`) from within a function handler. The logger automatically sends log events to the engine.
