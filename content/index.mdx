---
title: Welcome to iii
description: A backend unification and orchestration system.
hideCards: true
---

Today building a typical backend today means stitching together many separate systems:
an API framework, a task queue, a cron scheduler, a pub/sub layer, a state store, a WebSocket server,
and an observability pipeline.

Each system brings its own setup, its own deployment, and its own
failure modes. Balancing infrastructure and business logic becomes increasingly difficult
with every new system.

The result of balancing these many necessary systems are delayed delivery, difficulty debugging,
transient issues, increased expenses, silo'd domain and systems knowledge, and difficulty with
onboarding new developers and AI agents.

The key advantage of iii is that it transforms a backend from behaving like a series of
separate concerns, domains, and services to behaving like one cohesive and interoperable application.

**iii** (pronounced "three eye") does this by creating a single integration point
for all backend systems which results in a stack that is easy to adapt, to modify, and which
keeps all historical knowledge in one place (ie. a single config).

The result is easy onboarding of new developers and AI agents, easy debugging across systems,
removal of cost centers with reduced switching costs, and faster delivery of backend features.

## How iii achieves this

iii unifies any backend stack with a single engine and two primitives: **Function**, and **Trigger**.

Then it's a single process (or set of processes) that handles everything:

- **Write Functions in any language:** Use TypeScript, Python, or Rust. Mix them freely. Everything is just a Function.
- **Triggers handle any event:** An HTTP request, a cron schedule, a queue message, a state change, a stream event. They all work the same way: a Trigger fires, iii invokes your Function.
- **Discovery keeps everything in sync:** When a new function is registered with iii every other part of the stack can use it. Functions can deregister dynamically too allowing for seamless upgrading of production systems. No service registry, and no config files. iii always knows what the entire system can do.

<Callout title="Why this matters" type="info">
  React simplified the frontend with Component and Context. iii does the same for the backend with Function, Trigger, and Discovery. One mental model for every backend system.
</Callout>

## Getting Started

The best way to understand iii is to try it:

### 1. Install iii

Install and then update the iii-cli to get everything installed.

```bash
curl -fsSL https://install.iii.dev/iii-cli/main/install.sh | sh
iii-cli update
```

<Callout title="Anonymous telemetry" type="info">
  iii collects anonymous usage data to help improve the engine. No personal information is collected. To opt out, set this environment variable before running iii: `export III_TELEMETRY_ENABLED=false`
</Callout>

### 2. Verify installation

Check that iii has installed correctly with the following command. It should return a version number.

```bash
iii --version
```

## Next Steps

<Cards>
  <Card icon={<Terminal />} title="Tutorials" href={`/docs/tutorials/quickstart`}>
    Follow the Quickstart and build your first iii application step by step.
  </Card>
  <Card icon={<LayoutTemplate />} title="Concepts" href={`/docs/concepts`}>
    Understand Function, Trigger, and Discovery.
  </Card>
  <Card icon={<Settings />} title="How-to Guides" href={`/docs/how-to/expose-http-endpoint`}>
    Solve specific problems: HTTP endpoints, background jobs, state, cron, and streaming.
  </Card>
  <Card icon={<FileText />} title="SDK Reference" href={`/docs/api-reference/iii-sdk`}>
    Complete API reference for TypeScript, Python, and Rust SDKs.
  </Card>
</Cards>
